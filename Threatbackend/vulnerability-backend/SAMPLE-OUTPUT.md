# ðŸŽ¯ **Sample Output from Flexible File Parser**

## **What the Parser Should Produce:**

### **Input: Messy Scanner Output (JSON)**
```json
{
  "scan_results": {
    "findings": [
      {
        "cve_id": "CVE-2024-12345",
        "vuln_name": "Apache Log4j2 RCE",
        "vuln_desc": "Remote code execution vulnerability",
        "risk_level": "Critical",
        "target_host": "web-server-01",
        "cvss_value": "9.8"
      }
    ]
  }
}
```

### **Expected Output: Normalized Vulnerability**
```json
{
  "cveId": "CVE-2024-12345",
  "title": "Apache Log4j2 RCE",
  "description": "Remote code execution vulnerability",
  "scannerSource": "custom",
  "asset": "web-server-01",
  "assetCriticality": "Critical",
  "internetExposed": false,
  "publishedDate": "2024-01-15T10:00:00.000Z",
  "cvssScore": 9.8
}
```

## **How the Flexible Parser Works:**

### **Strategy 1: Known Formats**
- Looks for common scanner structures (Nessus, OpenVAS, etc.)
- Maps standard field names to normalized format

### **Strategy 2: Generic Structure**
- Finds any array that looks like vulnerability data
- Uses pattern recognition to identify security findings

### **Strategy 3: Deep Search**
- Searches entire file for CVE patterns (CVE-YYYY-NNNNN)
- Extracts context around found CVEs

### **Strategy 4: Pattern Matching**
- Looks for vulnerability indicators (severity, risk, threat)
- Matches common security terminology

### **Strategy 5: Any Data**
- Flattens complex structures
- Searches for any security-related fields

### **Strategy 6: Salvage Mode**
- Last resort: creates basic vulnerability from any security data found
- Provides fallback for completely unstructured files

## **Field Mapping Examples:**

| **Scanner Field** | **Normalized Field** | **Examples** |
|-------------------|----------------------|--------------|
| `cve`, `cve_id`, `vulnerability_id` | `cveId` | CVE-2024-12345 |
| `name`, `title`, `vuln_name` | `title` | SQL Injection |
| `description`, `desc`, `details` | `description` | Vulnerability details |
| `severity`, `risk`, `threat_level` | `severity` | Critical, High, Medium |
| `host`, `target`, `ip_address` | `asset` | web-server-01 |
| `cvss_score`, `score`, `risk_score` | `cvssScore` | 9.8 |

## **Quality Scoring:**

The parser provides a quality score (0-100) based on:
- **CVE ID presence** (25 points)
- **Title completeness** (20 points)  
- **Description quality** (15 points)
- **Severity mapping** (15 points)
- **Asset information** (10 points)
- **CVSS score** (10 points)
- **Date information** (5 points)

## **Error Handling:**

- **Specific error messages** for different failure types
- **Actionable suggestions** for fixing issues
- **Graceful degradation** when data is incomplete
- **Fallback strategies** for maximum compatibility

## **Supported Formats:**

âœ… **JSON** - Any structure with vulnerability data
âœ… **XML** - Standard and custom scanner outputs  
âœ… **CSV** - Column-based vulnerability reports
âœ… **Mixed formats** - Files with embedded data

## **Real-World Examples:**

### **Nessus Export (Modified Fields)**
```json
{
  "scan_results": [
    {
      "cve_reference": "CVE-2024-12346",
      "vulnerability_name": "OpenSSL DoS",
      "risk_level": "High",
      "target_host": "api-server-02"
    }
  ]
}
```

### **Custom Scanner Output**
```json
{
  "security_findings": {
    "hosts": [
      {
        "ip": "192.168.1.100",
        "issues": [
          "CVE-2024-12347 found in Apache",
          "CVE-2024-12348 detected in OpenSSL"
        ]
      }
    ]
  }
}
```

### **Minimal Data**
```json
{
  "scan_output": "CVE-2024-12350 detected on server",
  "timestamp": "2024-01-15T10:00:00Z"
}
```

## **Expected Results:**

The flexible parser should successfully extract vulnerabilities from ALL of these examples, even though they have completely different structures and field names.

**Key Point:** The parser is designed to work with ANY scanner output, no matter how messy or non-standard the format is.
