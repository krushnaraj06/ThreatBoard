const Vulnerability = require('../models/Vulnerability');

class FalsePositiveReduction {
  constructor() {
    // False positive indicators
    this.falsePositiveIndicators = {
      // Common false positive patterns
      patterns: {
        'version_check_failure': {
          pattern: /version.*check.*failed|unable.*to.*determine.*version/i,
          confidence: 0.8,
          reason: 'Version check failure - scanner unable to determine actual version'
        },
        'timeout_issues': {
          pattern: /timeout|connection.*refused|connection.*reset/i,
          confidence: 0.7,
          reason: 'Network timeout or connection issues during scan'
        },
        'authentication_required': {
          pattern: /authentication.*required|login.*required|access.*denied/i,
          confidence: 0.6,
          reason: 'Authentication required - may not be a real vulnerability'
        },
        'deprecated_software': {
          pattern: /deprecated|end.*of.*life|eol|unsupported/i,
          confidence: 0.5,
          reason: 'Software is deprecated or end-of-life'
        },
        'development_environment': {
          pattern: /dev|development|test|staging|localhost|127\.0\.0\.1/i,
          confidence: 0.4,
          reason: 'Development or test environment'
        }
      },
      
      // Technology-specific false positive rules
      technologyRules: {
        'wordpress': {
          'version_disclosure': {
            pattern: /wordpress.*version.*disclosure/i,
            confidence: 0.3,
            reason: 'WordPress version disclosure is often informational, not critical'
          },
          'plugin_vulnerabilities': {
            pattern: /plugin.*vulnerability|theme.*vulnerability/i,
            confidence: 0.6,
            reason: 'Plugin/theme vulnerabilities may not affect core system'
          }
        },
        'apache': {
          'server_signature': {
            pattern: /server.*signature|server.*banner/i,
            confidence: 0.4,
            reason: 'Server signature disclosure is often informational'
          }
        },
        'mysql': {
          'version_disclosure': {
            pattern: /mysql.*version.*disclosure/i,
            confidence: 0.3,
            reason: 'Database version disclosure is often informational'
          }
        }
      },
      
      // Context-based false positive indicators
      contextIndicators: {
        'low_risk_environment': {
          conditions: ['assetCriticality:Low', 'internetExposed:false'],
          confidence: 0.3,
          reason: 'Low-risk environment reduces vulnerability impact'
        },
        'recently_patched': {
          conditions: ['remediationStatus:Closed', 'lastPatched:<30days'],
          confidence: 0.6,
          reason: 'Recently patched vulnerabilities are less likely to be exploitable'
        },
        'scanner_limitations': {
          conditions: ['confidenceScore:<50', 'scannerSource:Unknown'],
          confidence: 0.5,
          reason: 'Low confidence or unknown scanner source'
        }
      }
    };

    // Confidence scoring weights
    this.confidenceWeights = {
      patternMatch: 0.4,
      technologyRule: 0.3,
      contextIndicator: 0.2,
      scannerReliability: 0.1
    };
  }

  /**
   * Analyze vulnerabilities for false positives
   */
  async analyzeFalsePositives(vulnerabilities, options = {}) {
    try {
      console.log(`🔍 Analyzing ${vulnerabilities.length} vulnerabilities for false positives...`);
      
      const analysisResults = [];
      let totalFalsePositives = 0;
      let totalConfirmed = 0;
      let totalUncertain = 0;

      for (const vulnerability of vulnerabilities) {
        const analysis = await this.analyzeVulnerability(vulnerability);
        analysisResults.push(analysis);

        if (analysis.falsePositiveConfidence >= 0.7) {
          totalFalsePositives++;
        } else if (analysis.falsePositiveConfidence <= 0.3) {
          totalConfirmed++;
        } else {
          totalUncertain++;
        }
      }

      const summary = {
        totalVulnerabilities: vulnerabilities.length,
        falsePositives: totalFalsePositives,
        confirmedVulnerabilities: totalConfirmed,
        uncertainVulnerabilities: totalUncertain,
        falsePositiveRate: Math.round((totalFalsePositives / vulnerabilities.length) * 100),
        analysisTimestamp: new Date().toISOString()
      };

      console.log(`✅ False positive analysis completed:`);
      console.log(`   - False Positives: ${totalFalsePositives}`);
      console.log(`   - Confirmed: ${totalConfirmed}`);
      console.log(`   - Uncertain: ${totalUncertain}`);
      console.log(`   - False Positive Rate: ${summary.falsePositiveRate}%`);

      return {
        summary,
        analysisResults,
        recommendations: this.generateRecommendations(summary, analysisResults)
      };

    } catch (error) {
      console.error('❌ False positive analysis failed:', error.message);
      throw new Error(`False positive analysis failed: ${error.message}`);
    }
  }

  /**
   * Analyze individual vulnerability for false positive indicators
   */
  async analyzeVulnerability(vulnerability) {
    const analysis = {
      vulnerabilityId: vulnerability._id || vulnerability.cveId,
      cveId: vulnerability.cveId,
      title: vulnerability.title,
      falsePositiveIndicators: [],
      falsePositiveConfidence: 0,
      risk: 'Unknown',
      recommendations: []
    };

    // Check pattern-based indicators
    const patternMatches = this.checkPatternIndicators(vulnerability);
    analysis.falsePositiveIndicators.push(...patternMatches);

    // Check technology-specific rules
    const technologyMatches = this.checkTechnologyRules(vulnerability);
    analysis.falsePositiveIndicators.push(...technologyMatches);

    // Check context-based indicators
    const contextMatches = this.checkContextIndicators(vulnerability);
    analysis.falsePositiveIndicators.push(...contextMatches);

    // Calculate overall false positive confidence
    analysis.falsePositiveConfidence = this.calculateFalsePositiveConfidence(analysis.falsePositiveIndicators);

    // Determine risk level
    analysis.risk = this.determineRiskLevel(analysis.falsePositiveConfidence, vulnerability);

    // Generate recommendations
    analysis.recommendations = this.generateVulnerabilityRecommendations(analysis, vulnerability);

    return analysis;
  }

  /**
   * Check pattern-based false positive indicators
   */
  checkPatternIndicators(vulnerability) {
    const matches = [];
    const textToCheck = `${vulnerability.title} ${vulnerability.description}`.toLowerCase();

    for (const [patternName, patternData] of Object.entries(this.falsePositiveIndicators.patterns)) {
      if (patternData.pattern.test(textToCheck)) {
        matches.push({
          type: 'pattern',
          name: patternName,
          confidence: patternData.confidence,
          reason: patternData.reason,
          weight: this.confidenceWeights.patternMatch
        });
      }
    }

    return matches;
  }

  /**
   * Check technology-specific false positive rules
   */
  checkTechnologyRules(vulnerability) {
    const matches = [];
    const textToCheck = `${vulnerability.title} ${vulnerability.description}`.toLowerCase();

    for (const [technology, rules] of Object.entries(this.falsePositiveIndicators.technologyRules)) {
      if (textToCheck.includes(technology.toLowerCase())) {
        for (const [ruleName, ruleData] of Object.entries(rules)) {
          if (ruleData.pattern.test(textToCheck)) {
            matches.push({
              type: 'technology',
              technology: technology,
              rule: ruleName,
              confidence: ruleData.confidence,
              reason: ruleData.reason,
              weight: this.confidenceWeights.technologyRule
            });
          }
        }
      }
    }

    return matches;
  }

  /**
   * Check context-based false positive indicators
   */
  checkContextIndicators(vulnerability) {
    const matches = [];

    for (const [indicatorName, indicatorData] of Object.entries(this.falsePositiveIndicators.contextIndicators)) {
      let conditionsMet = 0;
      const totalConditions = indicatorData.conditions.length;

      for (const condition of indicatorData.conditions) {
        const [field, value] = condition.split(':');
        
        if (this.evaluateCondition(vulnerability, field, value)) {
          conditionsMet++;
        }
      }

      // If most conditions are met, consider it a match
      if (conditionsMet / totalConditions >= 0.7) {
        matches.push({
          type: 'context',
          name: indicatorName,
          confidence: indicatorData.confidence,
          reason: indicatorData.reason,
          conditionsMet: conditionsMet,
          totalConditions: totalConditions,
          weight: this.confidenceWeights.contextIndicator
        });
      }
    }

    return matches;
  }

  /**
   * Evaluate a single condition against vulnerability data
   */
  evaluateCondition(vulnerability, field, value) {
    const fieldValue = vulnerability[field];
    
    if (value === 'true') {
      return fieldValue === true;
    } else if (value === 'false') {
      return fieldValue === false;
    } else if (value.startsWith('<')) {
      const threshold = parseInt(value.substring(1));
      return fieldValue < threshold;
    } else if (value.startsWith('>')) {
      const threshold = parseInt(value.substring(1));
      return fieldValue > threshold;
    } else {
      return fieldValue === value;
    }
  }

  /**
   * Calculate overall false positive confidence
   */
  calculateFalsePositiveConfidence(indicators) {
    if (indicators.length === 0) {
      return 0;
    }

    let weightedSum = 0;
    let totalWeight = 0;

    for (const indicator of indicators) {
      weightedSum += indicator.confidence * indicator.weight;
      totalWeight += indicator.weight;
    }

    return totalWeight > 0 ? weightedSum / totalWeight : 0;
  }

  /**
   * Determine risk level based on false positive confidence
   */
  determineRiskLevel(falsePositiveConfidence, vulnerability) {
    if (falsePositiveConfidence >= 0.7) {
      return 'Likely False Positive';
    } else if (falsePositiveConfidence >= 0.5) {
      return 'Potential False Positive';
    } else if (falsePositiveConfidence >= 0.3) {
      return 'Uncertain';
    } else {
      return 'Confirmed Vulnerability';
    }
  }

  /**
   * Generate recommendations for vulnerability
   */
  generateVulnerabilityRecommendations(analysis, vulnerability) {
    const recommendations = [];

    if (analysis.falsePositiveConfidence >= 0.7) {
      recommendations.push({
        action: 'Consider marking as false positive',
        priority: 'Medium',
        reason: 'High confidence this is a false positive'
      });
    } else if (analysis.falsePositiveConfidence >= 0.5) {
      recommendations.push({
        action: 'Manual verification recommended',
        priority: 'High',
        reason: 'Moderate confidence this might be a false positive'
      });
    }

    // Add specific recommendations based on indicators
    for (const indicator of analysis.falsePositiveIndicators) {
      if (indicator.confidence >= 0.6) {
        recommendations.push({
          action: 'Investigate specific indicator',
          priority: 'Medium',
          reason: indicator.reason
        });
      }
    }

    // Add general recommendations
    if (vulnerability.confidenceScore < 50) {
      recommendations.push({
        action: 'Re-run scan with different parameters',
        priority: 'High',
        reason: 'Low confidence score suggests scan may have failed'
      });
    }

    if (vulnerability.scannerSource === 'Unknown') {
      recommendations.push({
        action: 'Verify scanner output format',
        priority: 'Medium',
        reason: 'Unknown scanner source may indicate parsing issues'
      });
    }

    return recommendations;
  }

  /**
   * Generate overall recommendations for the analysis
   */
  generateRecommendations(summary, analysisResults) {
    const recommendations = [];

    if (summary.falsePositiveRate > 30) {
      recommendations.push({
        type: 'High False Positive Rate',
        action: 'Review scanner configuration and scan parameters',
        priority: 'High',
        reason: `${summary.falsePositiveRate}% false positive rate is above acceptable threshold`
      });
    }

    if (summary.uncertainVulnerabilities > summary.confirmedVulnerabilities) {
      recommendations.push({
        type: 'High Uncertainty',
        action: 'Implement additional verification processes',
        priority: 'Medium',
        reason: 'More uncertain vulnerabilities than confirmed ones'
      });
    }

    // Technology-specific recommendations
    const technologyIssues = this.analyzeTechnologyIssues(analysisResults);
    if (technologyIssues.length > 0) {
      recommendations.push({
        type: 'Technology-Specific Issues',
        action: 'Review technology-specific false positive rules',
        priority: 'Medium',
        reason: `Issues detected with ${technologyIssues.length} technologies`
      });
    }

    return recommendations;
  }

  /**
   * Analyze technology-specific issues
   */
  analyzeTechnologyIssues(analysisResults) {
    const technologyIssues = new Map();

    for (const analysis of analysisResults) {
      for (const indicator of analysis.falsePositiveIndicators) {
        if (indicator.type === 'technology') {
          const tech = indicator.technology;
          if (!technologyIssues.has(tech)) {
            technologyIssues.set(tech, []);
          }
          technologyIssues.get(tech).push(indicator);
        }
      }
    }

    return Array.from(technologyIssues.entries()).map(([tech, issues]) => ({
      technology: tech,
      issueCount: issues.length,
      averageConfidence: issues.reduce((sum, i) => sum + i.confidence, 0) / issues.length
    }));
  }

  /**
   * Get false positive statistics
   */
  async getFalsePositiveStatistics() {
    try {
      const stats = await Vulnerability.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            bySeverity: {
              $push: {
                severity: '$finalSeverity',
                cveId: '$cveId'
              }
            },
            byScanner: {
              $push: {
                scanner: '$scannerSource',
                cveId: '$cveId'
              }
            }
          }
        }
      ]);

      if (stats.length === 0) {
        return { total: 0, bySeverity: {}, byScanner: {} };
      }

      const result = stats[0];
      
      // Process severity breakdown
      const severityBreakdown = {};
      for (const item of result.bySeverity) {
        if (!severityBreakdown[item.severity]) {
          severityBreakdown[item.severity] = [];
        }
        severityBreakdown[item.severity].push(item.cveId);
      }

      // Process scanner breakdown
      const scannerBreakdown = {};
      for (const item of result.byScanner) {
        if (!scannerBreakdown[item.scanner]) {
          scannerBreakdown[item.scanner] = [];
        }
        scannerBreakdown[item.scanner].push(item.cveId);
      }

      return {
        total: result.total,
        bySeverity: severityBreakdown,
        byScanner: scannerBreakdown
      };

    } catch (error) {
      console.error('❌ Failed to get false positive statistics:', error.message);
      throw error;
    }
  }

  /**
   * Update false positive analysis for a vulnerability
   */
  async updateFalsePositiveAnalysis(vulnerabilityId, analysis) {
    try {
      const update = {
        falsePositiveAnalysis: analysis,
        lastFalsePositiveCheck: new Date().toISOString(),
        falsePositiveConfidence: analysis.falsePositiveConfidence,
        falsePositiveRisk: analysis.risk
      };

      await Vulnerability.findByIdAndUpdate(vulnerabilityId, update);
      console.log(`✅ Updated false positive analysis for vulnerability: ${vulnerabilityId}`);

      return { success: true, message: 'False positive analysis updated' };

    } catch (error) {
      console.error('❌ Failed to update false positive analysis:', error.message);
      throw error;
    }
  }
}

module.exports = new FalsePositiveReduction();
