const fs = require('fs');
const csv = require('csv-parser');
const xml2js = require('xml2js');
const path = require('path');

class FileParser {
  constructor() {
    this.xmlParser = new xml2js.Parser({ 
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: true,
      trim: true
    });
    
    // Common vulnerability indicators
    this.vulnerabilityIndicators = [
      'cve', 'vulnerability', 'vuln', 'finding', 'issue', 'problem',
      'security', 'risk', 'threat', 'exploit', 'weakness', 'flaw'
    ];
    
    // Common severity indicators
    this.severityIndicators = [
      'critical', 'high', 'medium', 'low', 'info', 'informational',
      'severe', 'moderate', 'minor', 'trivial'
    ];
  }

  /**
   * Parse scanner output file with maximum flexibility
   * @param {string} filePath - Path to the uploaded file
   * @param {string} scannerType - Type of scanner (auto-detected if not provided)
   * @returns {Promise<Array>} Array of parsed vulnerabilities
   */
  async parseFile(filePath, scannerType = 'auto') {
    const fileExtension = path.extname(filePath).toLowerCase();
    
    try {
      console.log(`ðŸ” Attempting to parse file: ${path.basename(filePath)}`);
      
      let vulnerabilities = [];
      
      switch (fileExtension) {
        case '.json':
          vulnerabilities = await this.parseJSONFlexible(filePath, scannerType);
          break;
        case '.csv':
          vulnerabilities = await this.parseCSVFlexible(filePath, scannerType);
          break;
        case '.xml':
          vulnerabilities = await this.parseXMLFlexible(filePath, scannerType);
          break;
        default:
          throw new Error(`Unsupported file format: ${fileExtension}`);
      }
      
      if (!vulnerabilities || vulnerabilities.length === 0) {
        // Last resort: try to salvage ANY data from the file
        vulnerabilities = await this.salvageAnyData(filePath, fileExtension);
      }
      
      if (!vulnerabilities || vulnerabilities.length === 0) {
        throw new Error('Could not extract any vulnerability data from the file. Please check the file content and format.');
      }
      
      console.log(`âœ… Successfully extracted ${vulnerabilities.length} vulnerabilities`);
      return vulnerabilities;
      
    } catch (error) {
      console.error(`âŒ File parsing failed: ${error.message}`);
      throw new Error(`Failed to parse file: ${error.message}`);
    }
  }

  /**
   * Flexible JSON parsing with multiple strategies
   */
  async parseJSONFlexible(filePath, scannerType) {
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      const data = JSON.parse(fileContent);
      
      console.log(`ðŸ“Š JSON file loaded, size: ${fileContent.length} characters`);
      
      // Try multiple extraction strategies
      const strategies = [
        () => this.extractFromKnownFormats(data, scannerType),
        () => this.extractFromGenericStructure(data),
        () => this.extractFromDeepSearch(data),
        () => this.extractFromPatternMatching(data),
        () => this.extractFromAnyData(data)
      ];
      
      for (let i = 0; i < strategies.length; i++) {
        try {
          console.log(`ðŸ”„ Trying strategy ${i + 1}: ${strategies[i].name}`);
          const result = strategies[i].call(this, data);
          
          if (result && result.length > 0) {
            console.log(`âœ… Strategy ${i + 1} succeeded: found ${result.length} vulnerabilities`);
            return result;
          }
        } catch (error) {
          console.log(`âš ï¸ Strategy ${i + 1} failed: ${error.message}`);
        }
      }
      
      return [];
      
    } catch (error) {
      throw new Error(`JSON parsing failed: ${error.message}`);
    }
  }

  /**
   * Flexible CSV parsing with intelligent column detection
   */
  async parseCSVFlexible(filePath, scannerType) {
    return new Promise((resolve, reject) => {
      const vulnerabilities = [];
      const rows = [];
      
      fs.createReadStream(filePath)
        .pipe(csv())
        .on('data', (row) => {
          rows.push(row);
          
          // Try to extract vulnerability from this row
          const vuln = this.extractVulnerabilityFromCSVRow(row, scannerType);
          if (vuln) {
            vulnerabilities.push(vuln);
          }
        })
        .on('end', () => {
          console.log(`ðŸ“Š CSV file processed: ${rows.length} rows, ${vulnerabilities.length} vulnerabilities found`);
          
          if (vulnerabilities.length === 0) {
            // Try alternative CSV parsing strategies
            const alternativeVulns = this.parseCSVAlternative(rows, scannerType);
            resolve(alternativeVulns);
          } else {
            resolve(vulnerabilities);
          }
        })
        .on('error', (error) => {
          reject(new Error(`CSV parsing failed: ${error.message}`));
        });
    });
  }

  /**
   * Flexible XML parsing with multiple strategies
   */
  async parseXMLFlexible(filePath, scannerType) {
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      console.log(`ðŸ“Š XML file loaded, size: ${fileContent.length} characters`);
      
      const result = await this.xmlParser.parseStringPromise(fileContent);
      
      // Try multiple extraction strategies
      const strategies = [
        () => this.extractFromKnownXMLFormats(result, scannerType),
        () => this.extractFromGenericXMLStructure(result),
        () => this.extractFromXMLDeepSearch(result),
        () => this.extractFromXMLPatternMatching(result),
        () => this.extractFromAnyXMLData(result)
      ];
      
      for (let i = 0; i < strategies.length; i++) {
        try {
          console.log(`ðŸ”„ Trying XML strategy ${i + 1}: ${strategies[i].name}`);
          const vulns = strategies[i].call(this, result);
          
          if (vulns && vulns.length > 0) {
            console.log(`âœ… XML strategy ${i + 1} succeeded: found ${vulns.length} vulnerabilities`);
            return vulns;
          }
        } catch (error) {
          console.log(`âš ï¸ XML strategy ${i + 1} failed: ${error.message}`);
        }
      }
      
      return [];
      
    } catch (error) {
      throw new Error(`XML parsing failed: ${error.message}`);
    }
  }

  /**
   * Extract from known scanner formats
   */
  extractFromKnownFormats(data, scannerType) {
    const knownFormats = {
      nessus: ['vulnerabilities', 'results', 'findings'],
      openvas: ['results', 'vulnerabilities', 'findings'],
      nmap: ['nmaprun', 'scan', 'results'],
      burp: ['scan', 'issues', 'vulnerabilities'],
      nikto: ['nikto', 'scan', 'results'],
      custom: ['vulnerabilities', 'findings', 'results', 'issues', 'data']
    };
    
    const formats = knownFormats[scannerType] || knownFormats.custom;
    
    for (const format of formats) {
      if (data[format] && Array.isArray(data[format])) {
        const vulns = this.parseVulnerabilityArray(data[format], scannerType);
        if (vulns.length > 0) return vulns;
      }
    }
    
    return [];
  }

  /**
   * Extract from generic data structure
   */
  extractFromGenericStructure(data) {
    const vulnerabilities = [];
    
    // Look for any array that might contain vulnerabilities
    const arrays = this.findArraysInObject(data);
    
    for (const array of arrays) {
      if (array.length > 0 && this.looksLikeVulnerabilityData(array[0])) {
        const vulns = this.parseVulnerabilityArray(array, 'generic');
        if (vulns.length > 0) {
          vulnerabilities.push(...vulns);
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Deep search for vulnerability data
   */
  extractFromDeepSearch(data) {
    const vulnerabilities = [];
    const allKeys = this.getAllKeys(data);
    
    // Look for CVE patterns
    const cvePattern = /CVE-\d{4}-\d+/g;
    const allText = JSON.stringify(data);
    const cves = allText.match(cvePattern);
    
    if (cves) {
      console.log(`ðŸ” Found ${cves.length} CVE references: ${cves.slice(0, 5).join(', ')}...`);
      
      // Try to extract context around each CVE
      for (const cve of cves) {
        const vuln = this.extractVulnerabilityFromCVE(cve, data);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Pattern matching for vulnerability data
   */
  extractFromPatternMatching(data) {
    const vulnerabilities = [];
    
    // Look for common vulnerability patterns
    const patterns = [
      { severity: /critical|high|medium|low/i, score: /cvss|score|risk/i },
      { cve: /cve-\d{4}-\d+/i, description: /vulnerability|weakness|flaw/i },
      { host: /host|ip|target/i, port: /port|service/i }
    ];
    
    for (const pattern of patterns) {
      const matches = this.findPatternMatches(data, pattern);
      if (matches.length > 0) {
        const vulns = this.createVulnerabilitiesFromPattern(matches);
        vulnerabilities.push(...vulns);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Extract from any data structure
   */
  extractFromAnyData(data) {
    const vulnerabilities = [];
    
    // Convert the entire object to a flat structure and look for clues
    const flatData = this.flattenObject(data);
    
    // Look for any fields that might indicate vulnerabilities
    for (const [key, value] of Object.entries(flatData)) {
      if (this.looksLikeVulnerabilityField(key, value)) {
        const vuln = this.createVulnerabilityFromField(key, value, flatData);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Alternative CSV parsing strategies
   */
  parseCSVAlternative(rows, scannerType) {
    if (rows.length === 0) return [];
    
    const vulnerabilities = [];
    const headers = Object.keys(rows[0]);
    
    console.log(`ðŸ” CSV headers detected: ${headers.join(', ')}`);
    
    // Strategy 1: Look for CVE columns
    const cveColumns = headers.filter(h => h.toLowerCase().includes('cve'));
    if (cveColumns.length > 0) {
      console.log(`âœ… Found CVE columns: ${cveColumns.join(', ')}`);
      
      for (const row of rows) {
        for (const cveCol of cveColumns) {
          if (row[cveCol] && row[cveCol] !== 'N/A' && row[cveCol] !== '') {
            const vuln = this.createVulnerabilityFromCSVRow(row, scannerType, cveCol);
            if (vuln) vulnerabilities.push(vuln);
          }
        }
      }
    }
    
    // Strategy 2: Look for any row with vulnerability-like data
    if (vulnerabilities.length === 0) {
      for (const row of rows) {
        if (this.rowContainsVulnerabilityData(row)) {
          const vuln = this.createVulnerabilityFromAnyCSVRow(row, scannerType);
          if (vuln) vulnerabilities.push(vuln);
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Extract from known XML formats
   */
  extractFromKnownXMLFormats(data, scannerType) {
    const knownFormats = {
      nessus: () => this.extractNessusXML(data),
      openvas: () => this.extractOpenVASXML(data),
      nmap: () => this.extractNmapXML(data),
      burp: () => this.extractBurpXML(data),
      nikto: () => this.extractNiktoXML(data)
    };
    
    if (knownFormats[scannerType]) {
      return knownFormats[scannerType]();
    }
    
    // Try all known formats
    for (const [format, extractor] of Object.entries(knownFormats)) {
      try {
        const vulns = extractor.call(this, data);
        if (vulns && vulns.length > 0) {
          console.log(`âœ… Successfully parsed as ${format} format`);
          return vulns;
        }
      } catch (error) {
        console.log(`âš ï¸ ${format} format parsing failed: ${error.message}`);
      }
    }
    
    return [];
  }

  /**
   * Extract from generic XML structure
   */
  extractFromGenericXMLStructure(data) {
    const vulnerabilities = [];
    
    // Look for common XML patterns
    const patterns = [
      '//item[contains(@class, "vulnerability")]',
      '//vulnerability',
      '//finding',
      '//issue',
      '//result',
      '//entry'
    ];
    
    // Try to find any XML elements that might contain vulnerability data
    const allElements = this.getAllXMLElements(data);
    
    for (const element of allElements) {
      if (this.xmlElementLooksLikeVulnerability(element)) {
        const vuln = this.extractVulnerabilityFromXMLElement(element);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Last resort: salvage any data from the file
   */
  async salvageAnyData(filePath, fileExtension) {
    console.log(`ðŸ†˜ Attempting to salvage any data from file...`);
    
    try {
      if (fileExtension === '.json') {
        const content = fs.readFileSync(filePath, 'utf8');
        const data = JSON.parse(content);
        return this.salvageFromAnyJSON(data);
      } else if (fileExtension === '.xml') {
        const content = fs.readFileSync(filePath, 'utf8');
        const result = await this.xmlParser.parseStringPromise(content);
        return this.salvageFromAnyXML(result);
      } else if (fileExtension === '.csv') {
        const content = fs.readFileSync(filePath, 'utf8');
        return this.salvageFromAnyCSV(content);
      }
    } catch (error) {
      console.log(`âš ï¸ Salvage attempt failed: ${error.message}`);
    }
    
    return [];
  }

  /**
   * Salvage from any JSON data
   */
  salvageFromAnyJSON(data) {
    const vulnerabilities = [];
    
    // Look for ANY data that might be useful
    const allText = JSON.stringify(data).toLowerCase();
    
    // Check if this looks like security data at all
    if (allText.includes('cve') || allText.includes('vulnerability') || 
        allText.includes('security') || allText.includes('scan')) {
      
      // Create a basic vulnerability from whatever we can find
      const vuln = {
        cveId: 'UNKNOWN-CVE',
        title: 'Vulnerability detected from scan output',
        description: 'Vulnerability data was found but could not be fully parsed. Please review the original file.',
        scannerSource: 'unknown',
        asset: 'Unknown',
        assetCriticality: 'Medium',
        internetExposed: false,
        publishedDate: new Date().toISOString(),
        cvssScore: 0
      };
      
      vulnerabilities.push(vuln);
    }
    
    return vulnerabilities;
  }

  /**
   * Helper methods
   */
  findArraysInObject(obj, arrays = []) {
    if (Array.isArray(obj)) {
      arrays.push(obj);
    } else if (typeof obj === 'object' && obj !== null) {
      for (const value of Object.values(obj)) {
        this.findArraysInObject(value, arrays);
      }
    }
    return arrays;
  }

  looksLikeVulnerabilityData(item) {
    if (!item || typeof item !== 'object') return false;
    
    const keys = Object.keys(item).map(k => k.toLowerCase());
    const values = Object.values(item).map(v => String(v).toLowerCase());
    
    // Check if this looks like vulnerability data
    const hasVulnIndicators = this.vulnerabilityIndicators.some(indicator => 
      keys.some(key => key.includes(indicator)) ||
      values.some(value => value.includes(indicator))
    );
    
    const hasSeverityIndicators = this.severityIndicators.some(indicator =>
      keys.some(key => key.includes(indicator)) ||
      values.some(value => value.includes(indicator))
    );
    
    return hasVulnIndicators || hasSeverityIndicators;
  }

  getAllKeys(obj, keys = []) {
    if (typeof obj === 'object' && obj !== null) {
      Object.keys(obj).forEach(key => {
        keys.push(key);
        this.getAllKeys(obj[key], keys);
      });
    }
    return keys;
  }

  extractVulnerabilityFromCVE(cveId, data) {
    // Try to find context around this CVE
    const context = this.findCVEContext(cveId, data);
    
    return {
      cveId: cveId,
      title: context.title || `Vulnerability ${cveId}`,
      description: context.description || `Vulnerability ${cveId} detected in scan output`,
      scannerSource: 'unknown',
      asset: context.asset || 'Unknown',
      assetCriticality: context.criticality || 'Medium',
      internetExposed: context.internetExposed || false,
      publishedDate: new Date().toISOString(),
      cvssScore: context.cvssScore || 0
    };
  }

  findCVEContext(cveId, data) {
    const context = {};
    const dataStr = JSON.stringify(data);
    
    // Look for context around the CVE
    const cveIndex = dataStr.indexOf(cveId);
    if (cveIndex > -1) {
      const surroundingText = dataStr.substring(Math.max(0, cveIndex - 200), cveIndex + 200);
      
      // Extract any useful information
      if (surroundingText.includes('title')) {
        const titleMatch = surroundingText.match(/"title"\s*:\s*"([^"]+)"/);
        if (titleMatch) context.title = titleMatch[1];
      }
      
      if (surroundingText.includes('description')) {
        const descMatch = surroundingText.match(/"description"\s*:\s*"([^"]+)"/);
        if (descMatch) context.description = descMatch[1];
      }
      
      if (surroundingText.includes('cvss')) {
        const cvssMatch = surroundingText.match(/"cvss[^"]*"\s*:\s*"?(\d+(?:\.\d+)?)"?/);
        if (cvssMatch) context.cvssScore = parseFloat(cvssMatch[1]);
      }
    }
    
    return context;
  }

  findPatternMatches(data, pattern) {
    const matches = [];
    const dataStr = JSON.stringify(data);
    
    for (const [key, regex] of Object.entries(pattern)) {
      const found = dataStr.match(regex);
      if (found) {
        matches.push({ key, value: found[0] });
      }
    }
    
    return matches;
  }

  createVulnerabilitiesFromPattern(matches) {
    if (matches.length === 0) return [];
    
    // Create a basic vulnerability from pattern matches
    const vuln = {
      cveId: 'PATTERN-MATCHED',
      title: 'Vulnerability detected from pattern matching',
      description: `Vulnerability indicators found: ${matches.map(m => `${m.key}: ${m.value}`).join(', ')}`,
      scannerSource: 'pattern-matched',
      asset: 'Unknown',
      assetCriticality: 'Medium',
      internetExposed: false,
      publishedDate: new Date().toISOString(),
      cvssScore: 0
    };
    
    return [vuln];
  }

  flattenObject(obj, prefix = '') {
    const flattened = {};
    
    for (const [key, value] of Object.entries(obj)) {
      const newKey = prefix ? `${prefix}.${key}` : key;
      
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        Object.assign(flattened, this.flattenObject(value, newKey));
      } else {
        flattened[newKey] = value;
      }
    }
    
    return flattened;
  }

  looksLikeVulnerabilityField(key, value) {
    const keyLower = key.toLowerCase();
    const valueStr = String(value).toLowerCase();
    
    // Check if this field looks like it contains vulnerability information
    return this.vulnerabilityIndicators.some(indicator => 
      keyLower.includes(indicator) || valueStr.includes(indicator)
    );
  }

  createVulnerabilityFromField(key, value, flatData) {
    // Try to create a vulnerability from this field
    const vuln = {
      cveId: 'FIELD-EXTRACTED',
      title: `Vulnerability found in ${key}`,
      description: `Vulnerability data extracted from field: ${key} = ${value}`,
      scannerSource: 'field-extraction',
      asset: 'Unknown',
      assetCriticality: 'Medium',
      internetExposed: false,
      publishedDate: new Date().toISOString(),
      cvssScore: 0
    };
    
    // Try to find related fields
    const relatedFields = this.findRelatedFields(key, flatData);
    if (relatedFields.severity) vuln.severity = relatedFields.severity;
    if (relatedFields.asset) vuln.asset = relatedFields.asset;
    
    return vuln;
  }

  findRelatedFields(key, flatData) {
    const related = {};
    const keyParts = key.split('.');
    
    // Look for related fields in the same object
    for (const [fieldKey, fieldValue] of Object.entries(flatData)) {
      if (fieldKey !== key && this.fieldsAreRelated(key, fieldKey)) {
        if (fieldKey.includes('severity') || fieldKey.includes('risk')) {
          related.severity = fieldValue;
        } else if (fieldKey.includes('host') || fieldKey.includes('asset')) {
          related.asset = fieldValue;
        }
      }
    }
    
    return related;
  }

  fieldsAreRelated(key1, key2) {
    const parts1 = key1.split('.');
    const parts2 = key2.split('.');
    
    // Check if fields are at the same level or closely related
    if (parts1.length === parts2.length) {
      const commonPrefix = parts1.slice(0, -1).join('.');
      const commonPrefix2 = parts2.slice(0, -1).join('.');
      return commonPrefix === commonPrefix2;
    }
    
    return false;
  }

  rowContainsVulnerabilityData(row) {
    const rowStr = JSON.stringify(row).toLowerCase();
    return this.vulnerabilityIndicators.some(indicator => 
      rowStr.includes(indicator)
    );
  }

  createVulnerabilityFromAnyCSVRow(row, scannerType) {
    // Create a vulnerability from any CSV row that looks suspicious
    const vuln = {
      cveId: 'CSV-EXTRACTED',
      title: 'Vulnerability detected in CSV data',
      description: `Vulnerability data found in CSV row: ${JSON.stringify(row)}`,
      scannerSource: scannerType || 'csv',
      asset: 'Unknown',
      assetCriticality: 'Medium',
      internetExposed: false,
      publishedDate: new Date().toISOString(),
      cvssScore: 0
    };
    
    // Try to extract any useful information
    for (const [key, value] of Object.entries(row)) {
      if (key.toLowerCase().includes('severity') || key.toLowerCase().includes('risk')) {
        vuln.severity = value;
      } else if (key.toLowerCase().includes('host') || key.toLowerCase().includes('target')) {
        vuln.asset = value;
      } else if (key.toLowerCase().includes('cve') && value && value !== 'N/A') {
        vuln.cveId = value;
      }
    }
    
    return vuln;
  }

  getAllXMLElements(data) {
    const elements = [];
    
    const traverse = (obj) => {
      if (obj && typeof obj === 'object') {
        elements.push(obj);
        for (const value of Object.values(obj)) {
          traverse(value);
        }
      }
    };
    
    traverse(data);
    return elements;
  }

  xmlElementLooksLikeVulnerability(element) {
    if (!element || typeof element !== 'object') return false;
    
    const elementStr = JSON.stringify(element).toLowerCase();
    return this.vulnerabilityIndicators.some(indicator => 
      elementStr.includes(indicator)
    );
  }

  extractVulnerabilityFromXMLElement(element) {
    // Try to extract vulnerability data from XML element
    const vuln = {
      cveId: 'XML-EXTRACTED',
      title: 'Vulnerability detected in XML data',
      description: `Vulnerability data extracted from XML element`,
      scannerSource: 'xml',
      asset: 'Unknown',
      assetCriticality: 'Medium',
      internetExposed: false,
      publishedDate: new Date().toISOString(),
      cvssScore: 0
    };
    
    // Try to find useful information in the element
    if (element.name) vuln.title = element.name;
    if (element.description) vuln.description = element.description;
    if (element.host) vuln.asset = element.host;
    if (element.severity) vuln.severity = element.severity;
    
    return vuln;
  }

  // Keep the original specific parser methods for known formats
  extractNessusXML(data) {
    // Original Nessus XML parsing logic
    return this.extractFromKnownFormats(data, 'nessus');
  }

  extractOpenVASXML(data) {
    // Original OpenVAS XML parsing logic
    return this.extractFromKnownFormats(data, 'openvas');
  }

  extractNmapXML(data) {
    // Original Nmap XML parsing logic
    return this.extractFromKnownFormats(data, 'nmap');
  }

  extractBurpXML(data) {
    // Original Burp XML parsing logic
    return this.extractFromKnownFormats(data, 'burp');
  }

  extractNiktoXML(data) {
    // Original Nikto XML parsing logic
    return this.extractFromKnownFormats(data, 'nikto');
  }

  // Keep the original CSV row parsing method
  extractVulnerabilityFromCSVRow(row, scannerType, cveColumn = null) {
    // Original CSV row parsing logic
    const normalizedRow = {};
    Object.keys(row).forEach(key => {
      normalizedRow[key.toLowerCase().replace(/\s+/g, '')] = row[key];
    });
    
    const cveId = cveColumn || normalizedRow.cve || normalizedRow.cveid || normalizedRow.cve_id || normalizedRow.id;
    
    if (cveId && cveId !== 'N/A' && cveId !== '') {
      return {
        cveId: cveId,
        title: normalizedRow.title || normalizedRow.name || normalizedRow.summary || 'Unknown Vulnerability',
        description: normalizedRow.description || normalizedRow.details || 'No description available',
        scannerSource: scannerType,
        asset: normalizedRow.asset || normalizedRow.host || normalizedRow.target || 'Unknown',
        assetCriticality: this.mapSeverityToCriticality(normalizedRow.severity || normalizedRow.risk || normalizedRow.threat),
        internetExposed: this.detectInternetExposed(normalizedRow.asset || normalizedRow.host),
        publishedDate: normalizedRow.published || normalizedRow.date || new Date().toISOString(),
        cvssScore: parseFloat(normalizedRow.cvssscore || normalizedRow.cvss_score) || 0
      };
    }
    
    return null;
  }

  // Keep the original helper methods
  mapSeverityToCriticality(severity) {
    if (!severity) return 'Medium';
    
    const sev = severity.toString().toLowerCase();
    if (sev.includes('critical') || sev.includes('crit')) return 'Critical';
    if (sev.includes('high')) return 'High';
    if (sev.includes('medium') || sev.includes('med')) return 'Medium';
    if (sev.includes('low')) return 'Low';
    
    return 'Medium';
  }

  detectInternetExposed(asset) {
    if (!asset) return false;
    
    const assetStr = asset.toString().toLowerCase();
    
    const internetIndicators = [
      'public', 'external', 'internet', 'dmz', 'edge', 'gateway',
      'loadbalancer', 'proxy', 'vpn', 'web', 'www', 'api'
    ];
    
    return internetIndicators.some(indicator => assetStr.includes(indicator));
  }

  /**
   * Parse vulnerability array with flexible field mapping
   */
  parseVulnerabilityArray(array, scannerType) {
    const vulnerabilities = [];
    
    for (const item of array) {
      if (!item || typeof item !== 'object') continue;
      
      // Try multiple field mappings
      const cveId = item.cve || item.cveId || item.cve_id || item.id || item.vulnerability_id;
      const title = item.title || item.name || item.summary || item.description || item.vulnerability_name;
      const description = item.description || item.summary || item.details || item.explanation || 'No description available';
      const severity = item.severity || item.risk || item.threat || item.level || item.priority;
      const host = item.host || item.asset || item.target || item.ip || item.address;
      const cvssScore = item.cvssScore || item.cvss_score || item.score || item.risk_score;
      
      if (cveId && cveId !== 'N/A' && cveId !== '') {
        const vuln = {
          cveId: cveId,
          title: title || `Vulnerability ${cveId}`,
          description: description,
          scannerSource: scannerType,
          asset: host || 'Unknown',
          assetCriticality: this.mapSeverityToCriticality(severity),
          internetExposed: this.detectInternetExposed(host),
          publishedDate: item.published || item.date || item.timestamp || new Date().toISOString(),
          cvssScore: parseFloat(cvssScore) || 0
        };
        
        vulnerabilities.push(vuln);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * XML deep search for vulnerability data
   */
  extractFromXMLDeepSearch(data) {
    const vulnerabilities = [];
    
    // Look for CVE patterns in XML
    const allText = JSON.stringify(data);
    const cvePattern = /CVE-\d{4}-\d+/g;
    const cves = allText.match(cvePattern);
    
    if (cves) {
      console.log(`ðŸ” Found ${cves.length} CVE references in XML: ${cves.slice(0, 5).join(', ')}...`);
      
      for (const cve of cves) {
        const vuln = this.extractVulnerabilityFromCVE(cve, data);
        if (vuln) {
          vuln.scannerSource = 'xml-deep-search';
          vulnerabilities.push(vuln);
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * XML pattern matching for vulnerability data
   */
  extractFromXMLPatternMatching(data) {
    const vulnerabilities = [];
    
    // Look for common XML vulnerability patterns
    const patterns = [
      { severity: /critical|high|medium|low/i, score: /cvss|score|risk/i },
      { cve: /cve-\d{4}-\d+/i, description: /vulnerability|weakness|flaw/i },
      { host: /host|ip|target/i, port: /port|service/i }
    ];
    
    for (const pattern of patterns) {
      const matches = this.findPatternMatches(data, pattern);
      if (matches.length > 0) {
        const vulns = this.createVulnerabilitiesFromPattern(matches);
        vulns.forEach(v => v.scannerSource = 'xml-pattern-match');
        vulnerabilities.push(...vulns);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Extract from any XML data structure
   */
  extractFromAnyXMLData(data) {
    const vulnerabilities = [];
    
    // Convert XML to flat structure and look for clues
    const flatData = this.flattenObject(data);
    
    for (const [key, value] of Object.entries(flatData)) {
      if (this.looksLikeVulnerabilityField(key, value)) {
        const vuln = this.createVulnerabilityFromField(key, value, flatData);
        if (vuln) {
          vuln.scannerSource = 'xml-any-data';
          vulnerabilities.push(vuln);
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Salvage from any XML data
   */
  salvageFromAnyXML(data) {
    const vulnerabilities = [];
    
    // Look for ANY data that might be useful
    const allText = JSON.stringify(data).toLowerCase();
    
    // Check if this looks like security data at all
    if (allText.includes('cve') || allText.includes('vulnerability') || 
        allText.includes('security') || allText.includes('scan') ||
        allText.includes('host') || allText.includes('port')) {
      
      // Create a basic vulnerability from whatever we can find
      const vuln = {
        cveId: 'XML-UNKNOWN-CVE',
        title: 'Vulnerability detected from XML scan output',
        description: 'Vulnerability data was found in XML but could not be fully parsed. Please review the original file.',
        scannerSource: 'xml-unknown',
        asset: 'Unknown',
        assetCriticality: 'Medium',
        internetExposed: false,
        publishedDate: new Date().toISOString(),
        cvssScore: 0
      };
      
      vulnerabilities.push(vuln);
    }
    
    return vulnerabilities;
  }

  /**
   * Salvage from any CSV data
   */
  salvageFromAnyCSV(content) {
    const vulnerabilities = [];
    
    // Look for ANY data that might be useful
    const lines = content.split('\n');
    
    if (lines.length > 1) {
      // Check if this looks like security data
      const allText = content.toLowerCase();
      if (allText.includes('cve') || allText.includes('vulnerability') || 
          allText.includes('security') || allText.includes('scan') ||
          allText.includes('host') || allText.includes('port')) {
        
        // Create a basic vulnerability from whatever we can find
        const vuln = {
          cveId: 'CSV-UNKNOWN-CVE',
          title: 'Vulnerability detected from CSV scan output',
          description: 'Vulnerability data was found in CSV but could not be fully parsed. Please review the original file.',
          scannerSource: 'csv-unknown',
          asset: 'Unknown',
          assetCriticality: 'Medium',
          internetExposed: false,
          publishedDate: new Date().toISOString(),
          cvssScore: 0
        };
        
        vulnerabilities.push(vuln);
      }
    }
    
    return vulnerabilities;
  }

  cleanupFile(filePath) {
    try {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    } catch (error) {
      console.error('Failed to cleanup file:', error);
    }
  }
}

module.exports = new FileParser();
