const Vulnerability = require('../models/Vulnerability');
const axios = require('axios');

class ScannerHealthMonitoring {
  constructor() {
    // Scanner performance thresholds
    this.performanceThresholds = {
      scanDuration: {
        warning: 3600000, // 1 hour
        critical: 7200000  // 2 hours
      },
      falsePositiveRate: {
        warning: 0.2, // 20%
        critical: 0.4  // 40%
      },
      coverage: {
        warning: 0.7, // 70%
        critical: 0.5  // 50%
      },
      confidenceScore: {
        warning: 60,
        critical: 40
      }
    };

    // Scanner health metrics
    this.healthMetrics = {
      nessus: { status: 'healthy', lastCheck: null, issues: [] },
      qualys: { status: 'healthy', lastCheck: null, issues: [] },
      rapid7: { status: 'healthy', lastCheck: null, issues: [] },
      openvas: { status: 'healthy', lastCheck: null, issues: [] },
      nmap: { status: 'healthy', lastCheck: null, issues: [] },
      burp: { status: 'healthy', lastCheck: null, issues: [] },
      custom: { status: 'healthy', lastCheck: null, issues: [] }
    };
  }

  /**
   * Monitor overall scanner health and performance
   */
  async monitorScannerHealth(options = {}) {
    try {
      console.log('üîç Monitoring scanner health and performance...');
      
      const healthReport = {
        timestamp: new Date().toISOString(),
        overallHealth: 'healthy',
        scannerStatus: {},
        performanceMetrics: {},
        recommendations: [],
        alerts: []
      };

      // Check each scanner's health
      for (const [scannerType, scannerInfo] of Object.entries(this.healthMetrics)) {
        const scannerHealth = await this.checkScannerHealth(scannerType);
        healthReport.scannerStatus[scannerType] = scannerHealth;
        
        // Update overall health
        if (scannerHealth.status === 'critical') {
          healthReport.overallHealth = 'critical';
        } else if (scannerHealth.status === 'warning' && healthReport.overallHealth === 'healthy') {
          healthReport.overallHealth = 'warning';
        }
      }

      // Get performance metrics
      healthReport.performanceMetrics = await this.getPerformanceMetrics();
      
      // Generate recommendations
      healthReport.recommendations = this.generateHealthRecommendations(healthReport);
      
      // Check for alerts
      healthReport.alerts = this.checkForAlerts(healthReport);

      console.log(`‚úÖ Scanner health monitoring completed. Overall status: ${healthReport.overallHealth}`);
      
      return healthReport;

    } catch (error) {
      console.error('‚ùå Scanner health monitoring failed:', error.message);
      throw new Error(`Scanner health monitoring failed: ${error.message}`);
    }
  }

  /**
   * Check health of a specific scanner
   */
  async checkScannerHealth(scannerType) {
    try {
      const health = {
        status: 'healthy',
        lastCheck: new Date().toISOString(),
        issues: [],
        metrics: {},
        recommendations: []
      };

      // Get scanner-specific metrics
      const metrics = await this.getScannerMetrics(scannerType);
      health.metrics = metrics;

      // Check for issues
      const issues = this.identifyScannerIssues(scannerType, metrics);
      health.issues = issues;

      // Determine status based on issues
      if (issues.some(issue => issue.severity === 'critical')) {
        health.status = 'critical';
      } else if (issues.some(issue => issue.severity === 'warning')) {
        health.status = 'warning';
      }

      // Generate scanner-specific recommendations
      health.recommendations = this.generateScannerRecommendations(scannerType, issues, metrics);

      // Update health metrics
      this.healthMetrics[scannerType] = {
        status: health.status,
        lastCheck: health.lastCheck,
        issues: issues
      };

      return health;

    } catch (error) {
      console.error(`‚ùå Failed to check health for ${scannerType}:`, error.message);
      return {
        status: 'unknown',
        lastCheck: new Date().toISOString(),
        issues: [{ severity: 'critical', message: `Health check failed: ${error.message}` }],
        metrics: {},
        recommendations: ['Investigate scanner connectivity and configuration']
      };
    }
  }

  /**
   * Get performance metrics for all scanners
   */
  async getPerformanceMetrics() {
    try {
      const metrics = {
        scanDuration: {},
        falsePositiveRate: {},
        coverage: {},
        confidenceScore: {},
        vulnerabilityCount: {},
        lastScan: {}
      };

      // Get metrics for each scanner type
      for (const scannerType of Object.keys(this.healthMetrics)) {
        const scannerMetrics = await this.getScannerMetrics(scannerType);
        
        metrics.scanDuration[scannerType] = scannerMetrics.averageScanDuration;
        metrics.falsePositiveRate[scannerType] = scannerMetrics.falsePositiveRate;
        metrics.coverage[scannerType] = scannerMetrics.assetCoverage;
        metrics.confidenceScore[scannerType] = scannerMetrics.averageConfidence;
        metrics.vulnerabilityCount[scannerType] = scannerMetrics.totalVulnerabilities;
        metrics.lastScan[scannerType] = scannerMetrics.lastScanTime;
      }

      return metrics;

    } catch (error) {
      console.error('‚ùå Failed to get performance metrics:', error.message);
      throw error;
    }
  }

  /**
   * Get metrics for a specific scanner
   */
  async getScannerMetrics(scannerType) {
    try {
      const pipeline = [
        { $match: { scannerSource: { $regex: scannerType, $options: 'i' } } },
        {
          $group: {
            _id: null,
            totalVulnerabilities: { $sum: 1 },
            averageConfidence: { $avg: '$confidenceScore' },
            averagePriorityScore: { $avg: '$priorityScore' },
            severityBreakdown: {
              $push: '$finalSeverity'
            },
            assetCount: { $addToSet: '$asset' },
            lastScanTime: { $max: '$discoveredDate' },
            falsePositiveCount: {
              $sum: {
                $cond: [
                  { $gte: ['$falsePositiveConfidence', 0.7] },
                  1,
                  0
                ]
              }
            }
          }
        }
      ];

      const results = await Vulnerability.aggregate(pipeline);
      
      if (results.length === 0) {
        return this.getDefaultScannerMetrics(scannerType);
      }

      const result = results[0];
      const totalVulns = result.totalVulnerabilities;
      const falsePositiveRate = totalVulns > 0 ? result.falsePositiveCount / totalVulns : 0;
      const assetCoverage = result.assetCount.length; // Simplified coverage calculation

      return {
        totalVulnerabilities: totalVulns,
        averageConfidence: Math.round(result.averageConfidence || 0),
        averagePriorityScore: Math.round(result.averagePriorityScore || 0),
        falsePositiveRate: Math.round(falsePositiveRate * 100),
        assetCoverage: assetCoverage,
        lastScanTime: result.lastScanTime,
        severityBreakdown: this.countSeverities(result.severityBreakdown),
        averageScanDuration: this.estimateScanDuration(scannerType, totalVulns)
      };

    } catch (error) {
      console.error(`‚ùå Failed to get metrics for ${scannerType}:`, error.message);
      return this.getDefaultScannerMetrics(scannerType);
    }
  }

  /**
   * Get default metrics when scanner data is unavailable
   */
  getDefaultScannerMetrics(scannerType) {
    return {
      totalVulnerabilities: 0,
      averageConfidence: 0,
      averagePriorityScore: 0,
      falsePositiveRate: 0,
      assetCoverage: 0,
      lastScanTime: null,
      severityBreakdown: { Critical: 0, High: 0, Medium: 0, Low: 0 },
      averageScanDuration: 0
    };
  }

  /**
   * Count vulnerabilities by severity
   */
  countSeverities(severityArray) {
    const counts = { Critical: 0, High: 0, Medium: 0, Low: 0 };
    severityArray.forEach(severity => {
      if (counts.hasOwnProperty(severity)) {
        counts[severity]++;
      }
    });
    return counts;
  }

  /**
   * Estimate scan duration based on vulnerability count and scanner type
   */
  estimateScanDuration(scannerType, vulnerabilityCount) {
    // Rough estimates based on scanner type and vulnerability count
    const baseDurations = {
      nessus: 300000,      // 5 minutes base
      qualys: 600000,      // 10 minutes base
      rapid7: 450000,      // 7.5 minutes base
      openvas: 900000,     // 15 minutes base
      nmap: 120000,        // 2 minutes base
      burp: 1800000,       // 30 minutes base
      custom: 600000        // 10 minutes base
    };

    const baseDuration = baseDurations[scannerType] || 600000;
    const perVulnTime = 5000; // 5 seconds per vulnerability
    
    return baseDuration + (vulnerabilityCount * perVulnTime);
  }

  /**
   * Identify issues with a scanner based on metrics
   */
  identifyScannerIssues(scannerType, metrics) {
    const issues = [];

    // Check scan duration
    if (metrics.averageScanDuration > this.performanceThresholds.scanDuration.critical) {
      issues.push({
        severity: 'critical',
        type: 'scan_duration',
        message: `Scan duration (${Math.round(metrics.averageScanDuration / 60000)}min) exceeds critical threshold`,
        recommendation: 'Optimize scan configuration or increase resources'
      });
    } else if (metrics.averageScanDuration > this.performanceThresholds.scanDuration.warning) {
      issues.push({
        severity: 'warning',
        type: 'scan_duration',
        message: `Scan duration (${Math.round(metrics.averageScanDuration / 60000)}min) exceeds warning threshold`,
        recommendation: 'Monitor scan performance and consider optimization'
      });
    }

    // Check false positive rate
    if (metrics.falsePositiveRate > this.performanceThresholds.falsePositiveRate.critical * 100) {
      issues.push({
        severity: 'critical',
        type: 'false_positive_rate',
        message: `False positive rate (${metrics.falsePositiveRate}%) exceeds critical threshold`,
        recommendation: 'Review scanner configuration and false positive rules'
      });
    } else if (metrics.falsePositiveRate > this.performanceThresholds.falsePositiveRate.warning * 100) {
      issues.push({
        severity: 'warning',
        type: 'false_positive_rate',
        message: `False positive rate (${metrics.falsePositiveRate}%) exceeds warning threshold`,
        recommendation: 'Monitor false positive trends and adjust rules'
      });
    }

    // Check coverage
    if (metrics.assetCoverage < this.performanceThresholds.coverage.critical * 100) {
      issues.push({
        severity: 'critical',
        type: 'coverage',
        message: `Asset coverage (${metrics.assetCoverage}) is below critical threshold`,
        recommendation: 'Review scan scope and network configuration'
      });
    } else if (metrics.assetCoverage < this.performanceThresholds.coverage.warning * 100) {
      issues.push({
        severity: 'warning',
        type: 'coverage',
        message: `Asset coverage (${metrics.assetCoverage}) is below warning threshold`,
        recommendation: 'Verify scan targets and network accessibility'
      });
    }

    // Check confidence score
    if (metrics.averageConfidence < this.performanceThresholds.confidenceScore.critical) {
      issues.push({
        severity: 'critical',
        type: 'confidence_score',
        message: `Average confidence score (${metrics.averageConfidence}) is below critical threshold`,
        recommendation: 'Investigate scanner configuration and output quality'
      });
    } else if (metrics.averageConfidence < this.performanceThresholds.confidenceScore.warning) {
      issues.push({
        severity: 'warning',
        type: 'confidence_score',
        message: `Average confidence score (${metrics.averageConfidence}) is below warning threshold`,
        recommendation: 'Review scanner settings and improve scan quality'
      });
    }

    // Check for stale data
    if (metrics.lastScanTime) {
      const daysSinceLastScan = (Date.now() - new Date(metrics.lastScanTime).getTime()) / (1000 * 60 * 60 * 24);
      if (daysSinceLastScan > 30) {
        issues.push({
          severity: 'warning',
          type: 'stale_data',
          message: `Last scan was ${Math.round(daysSinceLastScan)} days ago`,
          recommendation: 'Schedule regular scans to maintain current vulnerability data'
        });
      }
    }

    return issues;
  }

  /**
   * Generate recommendations for scanner health
   */
  generateScannerRecommendations(scannerType, issues, metrics) {
    const recommendations = [];

    // Add scanner-specific recommendations
    switch (scannerType) {
      case 'nessus':
        if (metrics.falsePositiveRate > 20) {
          recommendations.push('Review Nessus plugin configuration and false positive rules');
        }
        if (metrics.averageScanDuration > 3600000) {
          recommendations.push('Optimize Nessus scan policies and concurrent scan limits');
        }
        break;
        
      case 'qualys':
        if (metrics.assetCoverage < 70) {
          recommendations.push('Verify Qualys asset groups and scan targets');
        }
        if (metrics.averageConfidence < 60) {
          recommendations.push('Review Qualys scan options and authentication settings');
        }
        break;
        
      case 'openvas':
        if (metrics.falsePositiveRate > 30) {
          recommendations.push('Update OpenVAS NVT database and review scan configuration');
        }
        break;
        
      case 'nmap':
        if (metrics.averageScanDuration > 300000) {
          recommendations.push('Optimize Nmap scan timing and script selection');
        }
        break;
    }

    // Add general recommendations based on issues
    issues.forEach(issue => {
      if (issue.recommendation && !recommendations.includes(issue.recommendation)) {
        recommendations.push(issue.recommendation);
      }
    });

    return recommendations;
  }

  /**
   * Generate overall health recommendations
   */
  generateHealthRecommendations(healthReport) {
    const recommendations = [];

    // Check overall scanner health
    if (healthReport.overallHealth === 'critical') {
      recommendations.push('Immediate attention required: Critical scanner health issues detected');
    }

    // Check for common issues across scanners
    const commonIssues = this.findCommonIssues(healthReport.scannerStatus);
    if (commonIssues.length > 0) {
      recommendations.push(`Common issues detected across ${commonIssues.length} scanners: ${commonIssues.join(', ')}`);
    }

    // Performance optimization recommendations
    const performanceIssues = this.analyzePerformanceIssues(healthReport.performanceMetrics);
    if (performanceIssues.length > 0) {
      recommendations.push(...performanceIssues);
    }

    return recommendations;
  }

  /**
   * Find common issues across scanners
   */
  findCommonIssues(scannerStatus) {
    const issueTypes = new Map();
    
    Object.values(scannerStatus).forEach(status => {
      status.issues.forEach(issue => {
        if (!issueTypes.has(issue.type)) {
          issueTypes.set(issue.type, 0);
        }
        issueTypes.set(issue.type, issueTypes.get(issue.type) + 1);
      });
    });

    return Array.from(issueTypes.entries())
      .filter(([type, count]) => count > 1)
      .map(([type, count]) => `${type} (${count} scanners)`);
  }

  /**
   * Analyze performance issues across all scanners
   */
  analyzePerformanceIssues(performanceMetrics) {
    const recommendations = [];

    // Check for overall performance degradation
    const avgConfidence = Object.values(performanceMetrics.confidenceScore)
      .filter(score => score > 0)
      .reduce((sum, score) => sum + score, 0) / 
      Object.values(performanceMetrics.confidenceScore).filter(score => score > 0).length;

    if (avgConfidence < 60) {
      recommendations.push('Overall scanner confidence is low - review scanner configurations and network settings');
    }

    // Check for coverage issues
    const avgCoverage = Object.values(performanceMetrics.coverage)
      .filter(coverage => coverage > 0)
      .reduce((sum, coverage) => sum + coverage, 0) / 
      Object.values(performanceMetrics.coverage).filter(coverage => coverage > 0).length;

    if (avgCoverage < 50) {
      recommendations.push('Overall asset coverage is low - review network segmentation and scan policies');
    }

    return recommendations;
  }

  /**
   * Check for critical alerts
   */
  checkForAlerts(healthReport) {
    const alerts = [];

    // Critical scanner status
    Object.entries(healthReport.scannerStatus).forEach(([scanner, status]) => {
      if (status.status === 'critical') {
        alerts.push({
          level: 'critical',
          scanner: scanner,
          message: `Scanner ${scanner} is in critical condition`,
          timestamp: new Date().toISOString()
        });
      }
    });

    // Performance alerts
    if (healthReport.performanceMetrics) {
      Object.entries(healthReport.performanceMetrics.falsePositiveRate).forEach(([scanner, rate]) => {
        if (rate > 40) {
          alerts.push({
            level: 'warning',
            scanner: scanner,
            message: `High false positive rate (${rate}%) for ${scanner}`,
            timestamp: new Date().toISOString()
          });
        }
      });
    }

    return alerts;
  }

  /**
   * Get scanner health history
   */
  async getScannerHealthHistory(scannerType, days = 30) {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      // This would typically query a health history collection
      // For now, return mock data
      return {
        scanner: scannerType,
        days: days,
        history: [
          {
            date: new Date().toISOString(),
            status: 'healthy',
            metrics: await this.getScannerMetrics(scannerType)
          }
        ]
      };

    } catch (error) {
      console.error(`‚ùå Failed to get health history for ${scannerType}:`, error.message);
      throw error;
    }
  }
}

module.exports = new ScannerHealthMonitoring();
