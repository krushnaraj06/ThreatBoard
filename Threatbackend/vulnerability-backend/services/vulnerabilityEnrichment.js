const axios = require('axios');

class VulnerabilityEnrichment {
  constructor() {
    // NVD API v2 endpoints
    this.nvdBaseUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
    this.nvdSearchUrl = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
    
    // Alternative data sources
    this.cisaKevUrl = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json';
    this.exploitDbUrl = 'https://raw.githubusercontent.com/CVEProject/cvelist/master/recent';
    this.githubApiUrl = 'https://api.github.com/search/repositories';
    
    // Enhanced rate limiting and caching
    this.requestDelay = 120000; // 2 minutes between requests (NVD limit: 5 requests per 5 minutes)
    this.lastRequestTime = 0;
    this.requestCount = 0;
    this.maxRequestsPerWindow = 5;
    this.requestWindowMs = 300000; // 5 minutes
    
    // In-memory cache for NVD data
    this.nvdCache = new Map();
    this.cacheTTL = 3600000; // 1 hour cache
    
    // Fallback data for when NVD is unavailable
    this.fallbackData = new Map();
  }

  /**
   * Enrich vulnerability with data from multiple sources
   * @param {Object} vulnerability - Basic vulnerability object
   * @returns {Promise<Object>} Enriched vulnerability object
   */
  async enrichVulnerability(vulnerability) {
    try {
      const enriched = { ...vulnerability };
      
      // Enrich with NVD data (CVSS, description, severity)
      if (vulnerability.cveId && vulnerability.cveId !== 'N/A') {
        const nvdData = await this.getNVDData(vulnerability.cveId);
        if (nvdData) {
          enriched.cvssScore = nvdData.cvssScore || enriched.cvssScore;
          enriched.description = nvdData.description || enriched.description;
          enriched.severity = nvdData.severity || enriched.severity;
          enriched.publishedDate = nvdData.publishedDate || enriched.publishedDate;
          enriched.lastModifiedDate = nvdData.lastModifiedDate;
          enriched.cvssVector = nvdData.cvssVector;
          enriched.attackVector = nvdData.attackVector;
          enriched.attackComplexity = nvdData.attackComplexity;
          enriched.privilegesRequired = nvdData.privilegesRequired;
          enriched.userInteraction = nvdData.userInteraction;
          enriched.scope = nvdData.scope;
          enriched.confidentialityImpact = nvdData.confidentialityImpact;
          enriched.integrityImpact = nvdData.integrityImpact;
          enriched.availabilityImpact = nvdData.availabilityImpact;
        }
      }
      
      // Check if vulnerability is in CISA KEV
      enriched.cisaKevExploited = await this.checkCISAKEV(vulnerability.cveId);
      
      // Check for exploit availability
      enriched.exploitAvailable = await this.checkExploitAvailability(vulnerability.cveId);
      
      // Calculate priority score
      enriched.priorityScore = this.calculatePriorityScore(enriched);
      
      // Determine final severity
      enriched.finalSeverity = this.determineFinalSeverity(enriched);
      
      // Add remediation suggestions
      enriched.remediation = this.generateRemediationSuggestions(enriched);
      
      return enriched;
    } catch (error) {
      console.error(`Failed to enrich vulnerability ${vulnerability.cveId}:`, error);
      // Return basic vulnerability with default values if enrichment fails
      return {
        ...vulnerability,
        priorityScore: this.calculatePriorityScore(vulnerability),
        finalSeverity: this.determineFinalSeverity(vulnerability),
        remediation: this.generateRemediationSuggestions(vulnerability)
      };
    }
  }

  /**
   * Enhanced rate limiting for NVD API
   */
  async rateLimit() {
    const now = Date.now();
    
    // Check if we're within the rate limit window
    if (now - this.lastRequestTime < this.requestWindowMs) {
      this.requestCount++;
      
      if (this.requestCount >= this.maxRequestsPerWindow) {
        const waitTime = this.requestWindowMs - (now - this.lastRequestTime);
        console.log(`⚠️ NVD API rate limit reached. Waiting ${Math.round(waitTime / 1000)} seconds...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        this.requestCount = 0;
        this.lastRequestTime = Date.now();
      }
    } else {
      // Reset counter for new window
      this.requestCount = 1;
      this.lastRequestTime = now;
    }
    
    // Always wait minimum delay between requests
    const timeSinceLastRequest = now - this.lastRequestTime;
    if (timeSinceLastRequest < this.requestDelay) {
      const waitTime = this.requestDelay - timeSinceLastRequest;
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }

  /**
   * Get vulnerability data from NVD API with enhanced error handling
   */
  async getNVDData(cveId) {
    try {
      // Check cache first
      if (this.nvdCache.has(cveId)) {
        const cached = this.nvdCache.get(cveId);
        if (Date.now() - cached.timestamp < this.cacheTTL) {
          console.log(`📋 Using cached NVD data for ${cveId}`);
          return cached.data;
        }
      }
      
      // Check fallback data
      if (this.fallbackData.has(cveId)) {
        console.log(`🔄 Using fallback data for ${cveId}`);
        return this.fallbackData.get(cveId);
      }
      
      await this.rateLimit();
      
      console.log(`🔍 Fetching NVD data for ${cveId}...`);
      
      // Use the correct NVD API v2 query format
      const response = await axios.get(`${this.nvdSearchUrl}`, {
        params: {
          cveId: cveId
        },
        headers: {
          'User-Agent': 'ThreatBoard-Vulnerability-Management/1.0 (https://github.com/your-repo)',
          'Accept': 'application/json'
        },
        timeout: 15000
      });
      
      if (response.data && response.data.vulnerabilities && response.data.vulnerabilities.length > 0) {
        const vuln = response.data.vulnerabilities[0].cve;
        const metrics = vuln.metrics?.cvssMetricV31?.[0] || 
                       vuln.metrics?.cvssMetricV30?.[0] || 
                       vuln.metrics?.cvssMetricV2?.[0];
        
        const nvdData = {
          cvssScore: metrics?.cvssData?.baseScore || 0,
          severity: this.mapCVSSToSeverity(metrics?.cvssData?.baseScore),
          description: vuln.descriptions?.find(d => d.lang === 'en')?.value || 'No description available',
          publishedDate: vuln.published,
          lastModifiedDate: vuln.lastModified,
          cvssVector: metrics?.cvssData?.vectorString,
          attackVector: metrics?.cvssData?.attackVector,
          attackComplexity: metrics?.cvssData?.attackComplexity,
          privilegesRequired: metrics?.cvssData?.privilegesRequired,
          userInteraction: metrics?.cvssData?.userInteraction,
          scope: metrics?.cvssData?.scope,
          confidentialityImpact: metrics?.cvssData?.confidentialityImpact,
          integrityImpact: metrics?.cvssData?.integrityImpact,
          availabilityImpact: metrics?.cvssData?.availabilityImpact,
          baseSeverity: metrics?.cvssData?.baseSeverity
        };
        
        // Cache the successful response
        this.nvdCache.set(cveId, {
          data: nvdData,
          timestamp: Date.now()
        });
        
        console.log(`✅ Successfully fetched NVD data for ${cveId}`);
        return nvdData;
        
      } else {
        console.log(`⚠️ No NVD data found for ${cveId}`);
        return null;
      }
      
    } catch (error) {
      console.error(`❌ NVD API error for ${cveId}:`, error.message);
      
      // Handle specific error types
      if (error.response) {
        if (error.response.status === 429) {
          console.log(`🚫 Rate limit exceeded for ${cveId}. Using fallback data.`);
          return this.getFallbackData(cveId);
        } else if (error.response.status === 404) {
          console.log(`🔍 CVE ${cveId} not found in NVD database.`);
          return null;
        } else if (error.response.status >= 500) {
          console.log(`🔄 NVD API server error. Using fallback data for ${cveId}.`);
          return this.getFallbackData(cveId);
        }
      } else if (error.code === 'ECONNABORTED') {
        console.log(`⏰ NVD API timeout for ${cveId}. Using fallback data.`);
        return this.getFallbackData(cveId);
      }
      
      // Use fallback data for any other errors
      return this.getFallbackData(cveId);
    }
  }

  /**
   * Get fallback data when NVD API is unavailable
   */
  getFallbackData(cveId) {
    // Check if we have cached fallback data
    if (this.fallbackData.has(cveId)) {
      return this.fallbackData.get(cveId);
    }
    
    // Create basic fallback data
    const fallback = {
      cvssScore: 0,
      severity: 'Unknown',
      description: `Vulnerability ${cveId} - Data temporarily unavailable from NVD`,
      publishedDate: new Date().toISOString(),
      lastModifiedDate: new Date().toISOString(),
      cvssVector: 'N/A',
      attackVector: 'N/A',
      attackComplexity: 'N/A',
      privilegesRequired: 'N/A',
      userInteraction: 'N/A',
      scope: 'N/A',
      confidentialityImpact: 'N/A',
      integrityImpact: 'N/A',
      availabilityImpact: 'N/A',
      baseSeverity: 'Unknown'
    };
    
    // Cache fallback data
    this.fallbackData.set(cveId, fallback);
    
    return fallback;
  }

  /**
   * Check if vulnerability is in CISA Known Exploited Vulnerabilities
   */
  async checkCISAKEV(cveId) {
    try {
      await this.rateLimit(); // Apply rate limit to CISA KEV as well
      
      const response = await axios.get(this.cisaKevUrl, {
        timeout: 10000
      });
      
      if (response.data && response.data.vulnerabilities) {
        return response.data.vulnerabilities.some(vuln => 
          vuln.cveID === cveId
        );
      }
      
      return false;
    } catch (error) {
      console.error('Failed to check CISA KEV:', error.message);
      return false;
    }
  }

  /**
   * Check for exploit availability from multiple sources
   */
  async checkExploitAvailability(cveId) {
    try {
      // Check Exploit-DB (GitHub mirror)
      const exploitDbResult = await this.checkExploitDB(cveId);
      if (exploitDbResult) return true;
      
      // Check GitHub for PoC exploits
      const githubResult = await this.checkGitHubExploits(cveId);
      if (githubResult) return true;
      
      return false;
    } catch (error) {
      console.error('Failed to check exploit availability:', error.message);
      return false;
    }
  }

  /**
   * Check Exploit-DB for exploits
   */
  async checkExploitDB(cveId) {
    try {
      await this.rateLimit();
      
      // Check recent CVE list from Exploit-DB mirror
      const response = await axios.get(`${this.exploitDbUrl}/${cveId}.json`, {
        timeout: 5000
      });
      
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }

  /**
   * Check GitHub for PoC exploits
   */
  async checkGitHubExploits(cveId) {
    try {
      await this.rateLimit();
      
      const query = `${cveId} exploit poc`;
      const response = await axios.get(this.githubApiUrl, {
        params: {
          q: query,
          sort: 'stars',
          order: 'desc',
          per_page: 5
        },
        headers: {
          'Accept': 'application/vnd.github.v3+json',
          'User-Agent': 'ThreatBoard-Vulnerability-Management'
        },
        timeout: 10000
      });
      
      if (response.data && response.data.items) {
        // Check if any repository has exploit-related content
        const exploitIndicators = ['exploit', 'poc', 'proof-of-concept', 'vulnerability'];
        return response.data.items.some(repo => 
          exploitIndicators.some(indicator => 
            repo.name.toLowerCase().includes(indicator) ||
            repo.description?.toLowerCase().includes(indicator)
          )
        );
      }
      
      return false;
    } catch (error) {
      console.error('GitHub API error:', error.message);
      return false;
    }
  }

  /**
   * Calculate priority score based on multiple factors
   */
  calculatePriorityScore(vulnerability) {
    let score = 0;
    
    // Base CVSS score (weight: 0.5)
    if (vulnerability.cvssScore && vulnerability.cvssScore > 0) {
      score += (vulnerability.cvssScore / 10) * 50;
    }
    
    // Exploit available (+20 points)
    if (vulnerability.exploitAvailable) {
      score += 20;
    }
    
    // CISA KEV exploited (+30 points)
    if (vulnerability.cisaKevExploited) {
      score += 30;
    }
    
    // Asset criticality (weight: 0.3)
    const criticalityScore = this.getAssetCriticalityScore(vulnerability.assetCriticality);
    score += criticalityScore * 0.3;
    
    // Internet exposed (+15 points)
    if (vulnerability.internetExposed) {
      score += 15;
    }
    
    // Scanner source bonus
    if (vulnerability.scannerSource === 'nessus' || vulnerability.scannerSource === 'openvas') {
      score += 5;
    }
    
    // Ensure score doesn't exceed 100
    return Math.min(Math.round(score), 100);
  }

  /**
   * Get asset criticality score
   */
  getAssetCriticalityScore(criticality) {
    switch (criticality?.toLowerCase()) {
      case 'critical': return 100;
      case 'high': return 80;
      case 'medium': return 60;
      case 'low': return 40;
      default: return 60;
    }
  }

  /**
   * Determine final severity based on priority score and context
   */
  determineFinalSeverity(vulnerability) {
    const priorityScore = vulnerability.priorityScore || 0;
    
    if (priorityScore >= 90) return 'Critical';
    if (priorityScore >= 70) return 'High';
    if (priorityScore >= 50) return 'Medium';
    if (priorityScore >= 30) return 'Low';
    return 'Info';
  }

  /**
   * Generate remediation suggestions based on vulnerability data
   */
  generateRemediationSuggestions(vulnerability) {
    const suggestions = [];
    
    // Base remediation based on severity
    if (vulnerability.finalSeverity === 'Critical' || vulnerability.finalSeverity === 'High') {
      suggestions.push('Immediate patching required');
      suggestions.push('Implement temporary mitigations if patching is not immediately possible');
    }
    
    // Asset-specific suggestions
    if (vulnerability.internetExposed) {
      suggestions.push('Prioritize patching due to internet exposure');
      suggestions.push('Implement additional network segmentation');
    }
    
    if (vulnerability.assetCriticality === 'Critical') {
      suggestions.push('Critical asset - expedite remediation');
      suggestions.push('Consider business impact before patching');
    }
    
    // Exploit-specific suggestions
    if (vulnerability.exploitAvailable) {
      suggestions.push('Exploit available - immediate action required');
      suggestions.push('Implement intrusion detection/prevention');
    }
    
    if (vulnerability.cisaKevExploited) {
      suggestions.push('CISA KEV listed - federal compliance required');
      suggestions.push('Follow CISA guidance for remediation');
    }
    
    // CVSS-based suggestions
    if (vulnerability.cvssScore >= 9.0) {
      suggestions.push('Critical CVSS score - immediate attention required');
    } else if (vulnerability.cvssScore >= 7.0) {
      suggestions.push('High CVSS score - prioritize remediation');
    }
    
    // Default suggestion if none generated
    if (suggestions.length === 0) {
      suggestions.push('Review and patch according to standard procedures');
    }
    
    return suggestions;
  }

  /**
   * Map CVSS score to severity level
   */
  mapCVSSToSeverity(cvssScore) {
    if (!cvssScore || cvssScore === 0) return 'Unknown';
    if (cvssScore >= 9.0) return 'Critical';
    if (cvssScore >= 7.0) return 'High';
    if (cvssScore >= 4.0) return 'Medium';
    if (cvssScore >= 0.1) return 'Low';
    return 'Unknown';
  }

  /**
   * Batch enrich multiple vulnerabilities efficiently
   */
  async enrichVulnerabilities(vulnerabilities) {
    console.log(`🚀 Starting batch enrichment of ${vulnerabilities.length} vulnerabilities...`);
    
    const enriched = [];
    const batchSize = 3; // Process in small batches to respect rate limits
    
    for (let i = 0; i < vulnerabilities.length; i += batchSize) {
      const batch = vulnerabilities.slice(i, i + batchSize);
      console.log(`📦 Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(vulnerabilities.length / batchSize)}`);
      
      const batchPromises = batch.map(async (vuln) => {
        try {
          const enrichedVuln = await this.enrichVulnerability(vuln);
          return enrichedVuln;
        } catch (error) {
          console.error(`❌ Failed to enrich ${vuln.cveId}:`, error.message);
          // Return basic vulnerability with default values
          return {
            ...vuln,
            priorityScore: this.calculatePriorityScore(vuln),
            finalSeverity: this.determineFinalSeverity(vuln),
            remediation: this.generateRemediationSuggestions(vuln)
          };
        }
      });
      
      const batchResults = await Promise.all(batchPromises);
      enriched.push(...batchResults);
      
      // Add delay between batches to respect rate limits
      if (i + batchSize < vulnerabilities.length) {
        console.log(`⏳ Waiting between batches to respect rate limits...`);
        await new Promise(resolve => setTimeout(resolve, 5000)); // 5 second delay
      }
    }
    
    console.log(`✅ Batch enrichment completed: ${enriched.length} vulnerabilities processed`);
    return enriched;
  }

  /**
   * Get latest CVEs from NVD API for real-time updates
   */
  async getLatestCVEs(limit = 10, daysBack = 7) {
    try {
      await this.rateLimit();
      
      console.log(`🔍 Fetching latest ${limit} CVEs from NVD (last ${daysBack} days)...`);
      
      // Calculate date range
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - daysBack);
      
      const params = {
        resultsPerPage: Math.min(limit, 20), // NVD max is 20 per request
        startIndex: 0,
        pubStartDate: startDate.toISOString().split('T')[0] + 'T00:00:00:000 UTC-05:00',
        pubEndDate: endDate.toISOString().split('T')[0] + 'T23:59:59:999 UTC-05:00',
        orderBy: 'PUBLISH_DATE',
        sortOrder: 'DESC'
      };
      
      const response = await axios.get(this.nvdSearchUrl, {
        params: params,
        headers: {
          'User-Agent': 'ThreatBoard-Vulnerability-Management/1.0 (https://github.com/your-repo)',
          'Accept': 'application/json'
        },
        timeout: 20000
      });
      
      if (response.data && response.data.vulnerabilities) {
        const latestCVEs = response.data.vulnerabilities.slice(0, limit).map(vuln => {
          const cve = vuln.cve;
          const metrics = cve.metrics?.cvssMetricV31?.[0] || 
                         cve.metrics?.cvssMetricV30?.[0] || 
                         cve.metrics?.cvssMetricV2?.[0];
          
          return {
            cveId: cve.id,
            title: cve.descriptions?.find(d => d.lang === 'en')?.value?.substring(0, 100) + '...' || 'No description available',
            description: cve.descriptions?.find(d => d.lang === 'en')?.value || 'No description available',
            severity: this.mapCVSSToSeverity(metrics?.cvssData?.baseScore),
            cvssScore: metrics?.cvssData?.baseScore || 0,
            publishedDate: cve.published,
            lastModifiedDate: cve.lastModified,
            baseSeverity: metrics?.cvssData?.baseSeverity || 'Unknown',
            attackVector: metrics?.cvssData?.attackVector || 'N/A',
            attackComplexity: metrics?.cvssData?.attackComplexity || 'N/A',
            vectorString: metrics?.cvssData?.vectorString || 'N/A'
          };
        });
        
        console.log(`✅ Successfully fetched ${latestCVEs.length} latest CVEs from NVD`);
        return latestCVEs;
        
      } else {
        console.log(`⚠️ No latest CVEs found in NVD response`);
        return [];
      }
      
    } catch (error) {
      console.error(`❌ Failed to fetch latest CVEs from NVD:`, error.message);
      
      // Return fallback data when NVD is unavailable
      return this.getFallbackLatestCVEs(limit);
    }
  }

  /**
   * Get fallback latest CVEs when NVD API is unavailable
   */
  getFallbackLatestCVEs(limit) {
    console.log(`🔄 Using fallback latest CVEs data`);
    
    // Generate mock latest CVEs for demonstration
    const fallbackCVEs = [];
    const now = new Date();
    
    for (let i = 0; i < limit; i++) {
      const cveDate = new Date(now.getTime() - (i * 24 * 60 * 60 * 1000)); // Each CVE from different day
      
      fallbackCVEs.push({
        cveId: `CVE-2024-${String(10000 + i).padStart(5, '0')}`,
        title: `Sample vulnerability ${i + 1} - NVD data temporarily unavailable`,
        description: `This is fallback data generated when NVD API is unavailable. Please check back later for real-time updates.`,
        severity: ['Critical', 'High', 'Medium', 'Low'][i % 4],
        cvssScore: [9.8, 7.5, 5.5, 3.2][i % 4],
        publishedDate: cveDate.toISOString(),
        lastModifiedDate: cveDate.toISOString(),
        baseSeverity: ['Critical', 'High', 'Medium', 'Low'][i % 4],
        attackVector: 'Network',
        attackComplexity: 'Low',
        vectorString: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
      });
    }
    
    return fallbackCVEs;
  }

  /**
   * Search CVEs by keyword with rate limiting
   */
  async searchCVEsByKeyword(keyword, limit = 20) {
    try {
      await this.rateLimit();
      
      console.log(`🔍 Searching NVD for CVEs with keyword: "${keyword}"...`);
      
      const params = {
        keywordSearch: keyword,
        resultsPerPage: Math.min(limit, 20),
        startIndex: 0,
        orderBy: 'PUBLISH_DATE',
        sortOrder: 'DESC'
      };
      
      const response = await axios.get(this.nvdSearchUrl, {
        params: params,
        headers: {
          'User-Agent': 'ThreatBoard-Vulnerability-Management/1.0 (https://github.com/your-repo)',
          'Accept': 'application/json'
        },
        timeout: 20000
      });
      
      if (response.data && response.data.vulnerabilities) {
        const searchResults = response.data.vulnerabilities.slice(0, limit).map(vuln => {
          const cve = vuln.cve;
          const metrics = cve.metrics?.cvssMetricV31?.[0] || 
                         cve.metrics?.cvssMetricV30?.[0] || 
                         cve.metrics?.cvssMetricV2?.[0];
          
          return {
            cveId: cve.id,
            title: cve.descriptions?.find(d => d.lang === 'en')?.value?.substring(0, 100) + '...' || 'No description available',
            description: cve.descriptions?.find(d => d.lang === 'en')?.value || 'No description available',
            severity: this.mapCVSSToSeverity(metrics?.cvssData?.baseScore),
            cvssScore: metrics?.cvssData?.baseScore || 0,
            publishedDate: cve.published,
            lastModifiedDate: cve.lastModified,
            baseSeverity: metrics?.cvssData?.baseSeverity || 'Unknown'
          };
        });
        
        console.log(`✅ Found ${searchResults.length} CVEs matching keyword "${keyword}"`);
        return searchResults;
        
      } else {
        console.log(`⚠️ No CVEs found matching keyword "${keyword}"`);
        return [];
      }
      
    } catch (error) {
      console.error(`❌ Failed to search CVEs by keyword "${keyword}":`, error.message);
      return [];
    }
  }

  /**
   * Get NVD API status and health check
   */
  async getNVDStatus() {
    try {
      const response = await axios.get(this.nvdSearchUrl, {
        params: { resultsPerPage: 1 },
        headers: {
          'User-Agent': 'ThreatBoard-Vulnerability-Management/1.0 (https://github.com/your-repo)',
          'Accept': 'application/json'
        },
        timeout: 10000
      });
      
      return {
        status: 'healthy',
        responseTime: response.headers['x-response-time'] || 'unknown',
        timestamp: new Date().toISOString(),
        rateLimitRemaining: response.headers['x-ratelimit-remaining'] || 'unknown'
      };
      
    } catch (error) {
      return {
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date().toISOString(),
        suggestion: 'Check NVD API status at https://nvd.nist.gov/developers/vulnerabilities'
      };
    }
  }
}

module.exports = new VulnerabilityEnrichment();
