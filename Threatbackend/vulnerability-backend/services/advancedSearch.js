const Vulnerability = require('../models/Vulnerability');

class AdvancedSearch {
  constructor() {
    // Search operators and their meanings
    this.searchOperators = {
      'AND': '&&',
      'OR': '||',
      'NOT': '!',
      'GREATER_THAN': '>',
      'LESS_THAN': '<',
      'EQUALS': '=',
      'CONTAINS': '~',
      'REGEX': 'regex:',
      'DATE_RANGE': 'date:',
      'SEVERITY': 'severity:',
      'ASSET': 'asset:',
      'CVE': 'cve:',
      'SCANNER': 'scanner:',
      'PORT': 'port:',
      'SERVICE': 'service:'
    };

    // Predefined search templates
    this.searchTemplates = {
      'critical_internet_exposed': {
        name: 'Critical Internet-Exposed Vulnerabilities',
        query: 'severity:Critical && internetExposed:true',
        description: 'Find all critical vulnerabilities on internet-exposed assets'
      },
      'unpatched_critical': {
        name: 'Unpatched Critical Vulnerabilities',
        query: 'severity:Critical && remediationStatus:Open',
        description: 'Critical vulnerabilities that haven\'t been patched'
      },
      'recent_high_severity': {
        name: 'Recent High Severity Vulnerabilities',
        query: 'severity:High && discoveredDate:>7days',
        description: 'High severity vulnerabilities discovered in the last 7 days'
      },
      'cisa_kev_exploited': {
        name: 'CISA KEV Exploited Vulnerabilities',
        query: 'cisaKevExploited:true',
        description: 'Vulnerabilities listed in CISA Known Exploited Vulnerabilities'
      },
      'wordpress_vulnerabilities': {
        name: 'WordPress Vulnerabilities',
        query: 'description:~wordpress || title:~wordpress',
        description: 'All vulnerabilities related to WordPress'
      },
      'database_vulnerabilities': {
        name: 'Database Vulnerabilities',
        query: 'description:~database || service:~mysql || service:~postgresql || service:~oracle',
        description: 'Vulnerabilities affecting database services'
      }
    };
  }

  /**
   * Advanced search with natural language and complex queries
   */
  async advancedSearch(query, options = {}) {
    try {
      console.log(`🔍 Advanced search: "${query}"`);
      
      // Parse the search query
      const parsedQuery = this.parseSearchQuery(query);
      
      // Build MongoDB aggregation pipeline
      const pipeline = this.buildSearchPipeline(parsedQuery, options);
      
      // Execute search
      const results = await Vulnerability.aggregate(pipeline);
      
      // Apply post-processing
      const processedResults = this.postProcessResults(results, options);
      
      console.log(`✅ Search completed: ${processedResults.length} results found`);
      
      return {
        query: query,
        parsedQuery: parsedQuery,
        results: processedResults,
        total: processedResults.length,
        searchTime: new Date().toISOString(),
        suggestions: this.generateSearchSuggestions(query, processedResults)
      };
      
    } catch (error) {
      console.error('❌ Advanced search failed:', error.message);
      throw new Error(`Search failed: ${error.message}`);
    }
  }

  /**
   * Parse natural language search query into structured format
   */
  parseSearchQuery(query) {
    const parsed = {
      text: query,
      filters: [],
      operators: [],
      dateRanges: [],
      severityFilters: [],
      assetFilters: [],
      scannerFilters: []
    };

    // Handle natural language patterns
    if (query.toLowerCase().includes('critical vulnerabilities')) {
      parsed.severityFilters.push('Critical');
    }
    
    if (query.toLowerCase().includes('high severity')) {
      parsed.severityFilters.push('High');
    }
    
    if (query.toLowerCase().includes('internet exposed') || query.toLowerCase().includes('public facing')) {
      parsed.filters.push({ field: 'internetExposed', value: true, operator: '=' });
    }
    
    if (query.toLowerCase().includes('unpatched') || query.toLowerCase().includes('not patched')) {
      parsed.filters.push({ field: 'remediationStatus', value: 'Open', operator: '=' });
    }
    
    if (query.toLowerCase().includes('last week') || query.toLowerCase().includes('past week')) {
      parsed.dateRanges.push({ field: 'discoveredDate', start: '7days', end: 'now' });
    }
    
    if (query.toLowerCase().includes('last month') || query.toLowerCase().includes('past month')) {
      parsed.dateRanges.push({ field: 'discoveredDate', start: '30days', end: 'now' });
    }

    // Handle specific technology mentions
    const technologyPatterns = {
      'wordpress': ['description', 'title'],
      'apache': ['description', 'title', 'service'],
      'nginx': ['description', 'title', 'service'],
      'mysql': ['description', 'title', 'service'],
      'postgresql': ['description', 'title', 'service'],
      'docker': ['description', 'title', 'service'],
      'kubernetes': ['description', 'title', 'service']
    };

    for (const [tech, fields] of Object.entries(technologyPatterns)) {
      if (query.toLowerCase().includes(tech)) {
        fields.forEach(field => {
          parsed.filters.push({ field, value: tech, operator: '~', caseSensitive: false });
        });
      }
    }

    return parsed;
  }

  /**
   * Build MongoDB aggregation pipeline for search
   */
  buildSearchPipeline(parsedQuery, options) {
    const pipeline = [];
    
    // Text search stage
    if (parsedQuery.text && parsedQuery.text.length > 3) {
      pipeline.push({
        $search: {
          index: 'vulnerability_search',
          text: {
            query: parsedQuery.text,
            path: ['title', 'description', 'cveId', 'asset'],
            fuzzy: { maxEdits: 2 }
          }
        }
      });
    }

    // Match stage for filters
    const matchStage = {};
    
    // Severity filters
    if (parsedQuery.severityFilters.length > 0) {
      matchStage.finalSeverity = { $in: parsedQuery.severityFilters };
    }
    
    // Date range filters
    parsedQuery.dateRanges.forEach(dateRange => {
      if (dateRange.start === '7days') {
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        matchStage[dateRange.field] = { $gte: sevenDaysAgo };
      } else if (dateRange.start === '30days') {
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        matchStage[dateRange.field] = { $gte: thirtyDaysAgo };
      }
    });
    
    // Other filters
    parsedQuery.filters.forEach(filter => {
      if (filter.operator === '=') {
        matchStage[filter.field] = filter.value;
      } else if (filter.operator === '~') {
        if (filter.caseSensitive) {
          matchStage[filter.field] = { $regex: filter.value };
        } else {
          matchStage[filter.field] = { $regex: filter.value, $options: 'i' };
        }
      }
    });
    
    if (Object.keys(matchStage).length > 0) {
      pipeline.push({ $match: matchStage });
    }

    // Sort stage
    const sortStage = {};
    if (options.sortBy) {
      sortStage[options.sortBy] = options.sortOrder === 'desc' ? -1 : 1;
    } else {
      // Default sort: priority score descending, then severity
      sortStage.priorityScore = -1;
      sortStage.finalSeverity = -1;
    }
    pipeline.push({ $sort: sortStage });

    // Pagination
    if (options.limit) {
      pipeline.push({ $limit: options.limit });
    }
    
    if (options.skip) {
      pipeline.push({ $skip: options.skip });
    }

    // Project stage for final output
    pipeline.push({
      $project: {
        _id: 1,
        cveId: 1,
        title: 1,
        description: 1,
        finalSeverity: 1,
        priorityScore: 1,
        cvssScore: 1,
        asset: 1,
        assetCriticality: 1,
        internetExposed: 1,
        exploitAvailable: 1,
        cisaKevExploited: 1,
        remediationStatus: 1,
        discoveredDate: 1,
        scannerSource: 1,
        confidenceScore: 1,
        scannerSources: 1
      }
    });

    return pipeline;
  }

  /**
   * Post-process search results
   */
  postProcessResults(results, options) {
    return results.map(result => ({
      ...result,
      // Add computed fields
      riskLevel: this.calculateRiskLevel(result),
      businessImpact: this.calculateBusinessImpact(result),
      remediationPriority: this.calculateRemediationPriority(result)
    }));
  }

  /**
   * Calculate risk level based on multiple factors
   */
  calculateRiskLevel(vulnerability) {
    let riskScore = 0;
    
    // Base score from priority
    riskScore += vulnerability.priorityScore || 0;
    
    // Internet exposure bonus
    if (vulnerability.internetExposed) {
      riskScore += 20;
    }
    
    // Asset criticality bonus
    if (vulnerability.assetCriticality === 'Critical') {
      riskScore += 25;
    } else if (vulnerability.assetCriticality === 'High') {
      riskScore += 15;
    }
    
    // Exploit availability bonus
    if (vulnerability.exploitAvailable) {
      riskScore += 15;
    }
    
    // CISA KEV bonus
    if (vulnerability.cisaKevExploited) {
      riskScore += 20;
    }
    
    // Normalize to 0-100 scale
    return Math.min(Math.round(riskScore / 2), 100);
  }

  /**
   * Calculate business impact score
   */
  calculateBusinessImpact(vulnerability) {
    let impactScore = 0;
    
    // Asset criticality
    switch (vulnerability.assetCriticality) {
      case 'Critical': impactScore += 40; break;
      case 'High': impactScore += 30; break;
      case 'Medium': impactScore += 20; break;
      case 'Low': impactScore += 10; break;
    }
    
    // Internet exposure
    if (vulnerability.internetExposed) {
      impactScore += 30;
    }
    
    // Vulnerability severity
    switch (vulnerability.finalSeverity) {
      case 'Critical': impactScore += 30; break;
      case 'High': impactScore += 20; break;
      case 'Medium': impactScore += 10; break;
    }
    
    return Math.min(impactScore, 100);
  }

  /**
   * Calculate remediation priority
   */
  calculateRemediationPriority(vulnerability) {
    const riskLevel = this.calculateRiskLevel(vulnerability);
    const businessImpact = this.calculateBusinessImpact(vulnerability);
    
    // Weighted average: 60% risk, 40% business impact
    const priority = (riskLevel * 0.6) + (businessImpact * 0.4);
    
    if (priority >= 80) return 'Immediate';
    if (priority >= 60) return 'High';
    if (priority >= 40) return 'Medium';
    if (priority >= 20) return 'Low';
    return 'Defer';
  }

  /**
   * Generate search suggestions based on results
   */
  generateSearchSuggestions(query, results) {
    const suggestions = [];
    
    // Suggest related searches based on results
    if (results.length > 0) {
      const topResult = results[0];
      
      if (topResult.asset) {
        suggestions.push(`asset:${topResult.asset}`);
      }
      
      if (topResult.finalSeverity) {
        suggestions.push(`severity:${topResult.finalSeverity}`);
      }
      
      if (topResult.scannerSource) {
        suggestions.push(`scanner:${topResult.scannerSource}`);
      }
    }
    
    // Suggest template searches
    Object.entries(this.searchTemplates).forEach(([key, template]) => {
      if (!query.toLowerCase().includes(template.name.toLowerCase())) {
        suggestions.push(template.name);
      }
    });
    
    return suggestions.slice(0, 5); // Limit to 5 suggestions
  }

  /**
   * Save a search query for later use
   */
  async saveSearch(name, query, description, userId) {
    try {
      // This would typically save to a database
      const savedSearch = {
        name,
        query,
        description,
        userId,
        createdAt: new Date().toISOString(),
        usageCount: 0
      };
      
      console.log(`💾 Saved search: ${name}`);
      return savedSearch;
      
    } catch (error) {
      console.error('❌ Failed to save search:', error.message);
      throw error;
    }
  }

  /**
   * Get saved searches for a user
   */
  async getSavedSearches(userId) {
    try {
      // This would typically fetch from a database
      const savedSearches = Object.entries(this.searchTemplates).map(([key, template]) => ({
        id: key,
        name: template.name,
        query: template.query,
        description: template.description,
        isTemplate: true,
        createdAt: new Date().toISOString()
      }));
      
      return savedSearches;
      
    } catch (error) {
      console.error('❌ Failed to get saved searches:', error.message);
      throw error;
    }
  }

  /**
   * Execute a saved search
   */
  async executeSavedSearch(searchId, options = {}) {
    try {
      const savedSearch = this.searchTemplates[searchId];
      if (!savedSearch) {
        throw new Error(`Saved search not found: ${searchId}`);
      }
      
      return await this.advancedSearch(savedSearch.query, options);
      
    } catch (error) {
      console.error('❌ Failed to execute saved search:', error.message);
      throw error;
    }
  }

  /**
   * Get search statistics and analytics
   */
  async getSearchAnalytics() {
    try {
      const analytics = {
        totalVulnerabilities: await Vulnerability.countDocuments(),
        severityDistribution: await Vulnerability.aggregate([
          { $group: { _id: '$finalSeverity', count: { $sum: 1 } } },
          { $sort: { count: -1 } }
        ]),
        assetCriticalityDistribution: await Vulnerability.aggregate([
          { $group: { _id: '$assetCriticality', count: { $sum: 1 } } },
          { $sort: { count: -1 } }
        ]),
        scannerDistribution: await Vulnerability.aggregate([
          { $group: { _id: '$scannerSource', count: { $sum: 1 } } },
          { $sort: { count: -1 } }
        ]),
        remediationStatusDistribution: await Vulnerability.aggregate([
          { $group: { _id: '$remediationStatus', count: { $sum: 1 } } },
          { $sort: { count: -1 } }
        ])
      };
      
      return analytics;
      
    } catch (error) {
      console.error('❌ Failed to get search analytics:', error.message);
      throw error;
    }
  }
}

module.exports = new AdvancedSearch();
