const axios = require('axios');
const fs = require('fs');
const path = require('path');

class ScannerIntegration {
  constructor() {
    // Supported scanner types
    this.supportedScanners = {
      nessus: {
        name: 'Nessus',
        parser: this.parseNessusOutput,
        priority: 1
      },
      qualys: {
        name: 'Qualys',
        parser: this.parseQualysOutput,
        priority: 2
      },
      rapid7: {
        name: 'Rapid7 InsightVM',
        parser: this.parseRapid7Output,
        priority: 3
      },
      openvas: {
        name: 'OpenVAS',
        parser: this.parseOpenVASOutput,
        priority: 4
      },
      nmap: {
        name: 'Nmap',
        parser: this.parseNmapOutput,
        priority: 5
      },
      burp: {
        name: 'Burp Suite',
        parser: this.parseBurpOutput,
        priority: 6
      },
      custom: {
        name: 'Custom Scanner',
        parser: this.parseCustomOutput,
        priority: 7
      }
    };

    // Scanner comparison metrics
    this.comparisonMetrics = {
      coverage: 'asset_coverage',
      vulnerability_count: 'total_vulnerabilities',
      critical_count: 'critical_vulnerabilities',
      false_positive_rate: 'estimated_false_positives',
      scan_duration: 'scan_time',
      last_scan: 'last_scan_timestamp'
    };
  }

  /**
   * Integrate multiple scanner outputs and provide unified view
   */
  async integrateScannerOutputs(scannerFiles) {
    try {
      console.log(`🔗 Integrating ${scannerFiles.length} scanner outputs...`);
      
      const scannerResults = {};
      const unifiedVulnerabilities = [];
      const scannerComparison = {};

      // Parse each scanner output
      for (const scannerFile of scannerFiles) {
        const scannerType = this.detectScannerType(scannerFile);
        const scannerName = this.supportedScanners[scannerType]?.name || 'Unknown';
        
        console.log(`📊 Processing ${scannerName} output...`);
        
        const vulnerabilities = await this.parseScannerOutput(scannerFile, scannerType);
        scannerResults[scannerType] = {
          name: scannerName,
          vulnerabilities: vulnerabilities,
          metadata: this.extractScannerMetadata(scannerFile, scannerType),
          timestamp: new Date().toISOString()
        };
      }

      // Merge and deduplicate vulnerabilities
      const mergedVulnerabilities = this.mergeVulnerabilities(Object.values(scannerResults));
      
      // Generate scanner comparison
      const comparison = this.generateScannerComparison(scannerResults);
      
      // Calculate coverage and statistics
      const statistics = this.calculateUnifiedStatistics(mergedVulnerabilities, scannerResults);

      return {
        unifiedVulnerabilities: mergedVulnerabilities,
        scannerResults: scannerResults,
        comparison: comparison,
        statistics: statistics,
        metadata: {
          totalScanners: Object.keys(scannerResults).length,
          totalVulnerabilities: mergedVulnerabilities.length,
          integrationTimestamp: new Date().toISOString()
        }
      };

    } catch (error) {
      console.error('❌ Scanner integration failed:', error.message);
      throw new Error(`Scanner integration failed: ${error.message}`);
    }
  }

  /**
   * Detect scanner type from file content
   */
  detectScannerType(filePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const fileName = path.basename(filePath).toLowerCase();
      
      // Check file extension and content patterns
      if (fileName.includes('nessus') || content.includes('Nessus')) {
        return 'nessus';
      } else if (fileName.includes('qualys') || content.includes('Qualys')) {
        return 'qualys';
      } else if (fileName.includes('rapid7') || content.includes('Rapid7')) {
        return 'rapid7';
      } else if (fileName.includes('openvas') || content.includes('OpenVAS')) {
        return 'openvas';
      } else if (fileName.includes('nmap') || content.includes('nmap')) {
        return 'nmap';
      } else if (fileName.includes('burp') || content.includes('Burp')) {
        return 'burp';
      } else {
        return 'custom';
      }
    } catch (error) {
      return 'custom';
    }
  }

  /**
   * Parse scanner output based on type
   */
  async parseScannerOutput(filePath, scannerType) {
    const parser = this.supportedScanners[scannerType]?.parser;
    if (!parser) {
      throw new Error(`No parser available for scanner type: ${scannerType}`);
    }
    
    return await parser.call(this, filePath);
  }

  /**
   * Merge vulnerabilities from multiple scanners with deduplication
   */
  mergeVulnerabilities(scannerResults) {
    const vulnerabilityMap = new Map();
    const duplicates = [];
    const conflicts = [];

    for (const scannerResult of scannerResults) {
      for (const vuln of scannerResult.vulnerabilities) {
        const key = this.generateVulnerabilityKey(vuln);
        
        if (vulnerabilityMap.has(key)) {
          const existing = vulnerabilityMap.get(key);
          
          // Check for conflicts (different severity, CVSS scores, etc.)
          if (this.hasConflicts(existing, vuln)) {
            conflicts.push({
              cveId: vuln.cveId,
              scanner1: existing.scannerSource,
              scanner2: vuln.scannerSource,
              conflict: this.identifyConflict(existing, vuln)
            });
          }
          
          // Merge with confidence scoring
          const merged = this.mergeVulnerabilityData(existing, vuln);
          vulnerabilityMap.set(key, merged);
          duplicates.push(key);
        } else {
          vulnerabilityMap.set(key, vuln);
        }
      }
    }

    console.log(`🔗 Merged ${vulnerabilityMap.size} unique vulnerabilities`);
    console.log(`🔄 Found ${duplicates.length} duplicates across scanners`);
    if (conflicts.length > 0) {
      console.log(`⚠️ Found ${conflicts.length} conflicts between scanners`);
    }

    return Array.from(vulnerabilityMap.values());
  }

  /**
   * Generate unique key for vulnerability deduplication
   */
  generateVulnerabilityKey(vulnerability) {
    // Use CVE ID if available, otherwise create composite key
    if (vulnerability.cveId && vulnerability.cveId !== 'N/A') {
      return `cve:${vulnerability.cveId}`;
    }
    
    // Composite key for vulnerabilities without CVE
    const asset = vulnerability.asset || 'unknown';
    const title = vulnerability.title || 'unknown';
    const port = vulnerability.port || 'unknown';
    
    return `asset:${asset}:title:${title}:port:${port}`;
  }

  /**
   * Check for conflicts between vulnerability data from different scanners
   */
  hasConflicts(vuln1, vuln2) {
    // Check severity conflicts
    if (vuln1.severity && vuln2.severity && vuln1.severity !== vuln2.severity) {
      return true;
    }
    
    // Check CVSS score conflicts (significant difference)
    if (vuln1.cvssScore && vuln2.cvssScore) {
      const difference = Math.abs(vuln1.cvssScore - vuln2.cvssScore);
      if (difference > 2.0) { // More than 2 point difference
        return true;
      }
    }
    
    // Check description conflicts
    if (vuln1.description && vuln2.description) {
      const similarity = this.calculateTextSimilarity(vuln1.description, vuln2.description);
      if (similarity < 0.3) { // Less than 30% similar
        return true;
      }
    }
    
    return false;
  }

  /**
   * Identify specific conflicts between vulnerability data
   */
  identifyConflict(vuln1, vuln2) {
    const conflicts = [];
    
    if (vuln1.severity !== vuln2.severity) {
      conflicts.push(`Severity: ${vuln1.severity} vs ${vuln2.severity}`);
    }
    
    if (vuln1.cvssScore && vuln2.cvssScore) {
      const difference = Math.abs(vuln1.cvssScore - vuln2.cvssScore);
      if (difference > 2.0) {
        conflicts.push(`CVSS Score: ${vuln1.cvssScore} vs ${vuln2.cvssScore} (diff: ${difference.toFixed(1)})`);
      }
    }
    
    return conflicts;
  }

  /**
   * Merge vulnerability data with confidence scoring
   */
  mergeVulnerabilityData(vuln1, vuln2) {
    const merged = { ...vuln1 };
    
    // Add scanner source information
    merged.scannerSources = [vuln1.scannerSource, vuln2.scannerSource];
    merged.confidenceScore = this.calculateConfidenceScore(vuln1, vuln2);
    
    // Merge with preference for higher confidence data
    if (vuln2.cvssScore > vuln1.cvssScore) {
      merged.cvssScore = vuln2.cvssScore;
      merged.severity = vuln2.severity;
    }
    
    if (vuln2.description && vuln2.description.length > vuln1.description?.length) {
      merged.description = vuln2.description;
    }
    
    // Merge additional fields
    merged.ports = [...new Set([...(vuln1.ports || []), ...(vuln2.ports || [])])];
    merged.services = [...new Set([...(vuln1.services || []), ...(vuln2.services || [])])];
    
    return merged;
  }

  /**
   * Calculate confidence score for merged vulnerability
   */
  calculateConfidenceScore(vuln1, vuln2) {
    let score = 50; // Base score
    
    // Bonus for CVE ID
    if (vuln1.cveId && vuln1.cveId !== 'N/A') score += 20;
    if (vuln2.cveId && vuln2.cveId !== 'N/A') score += 20;
    
    // Bonus for detailed descriptions
    if (vuln1.description && vuln1.description.length > 100) score += 10;
    if (vuln2.description && vuln2.description.length > 100) score += 10;
    
    // Bonus for CVSS scores
    if (vuln1.cvssScore > 0) score += 10;
    if (vuln2.cvssScore > 0) score += 10;
    
    return Math.min(score, 100);
  }

  /**
   * Generate scanner comparison metrics
   */
  generateScannerComparison(scannerResults) {
    const comparison = {};
    
    for (const [scannerType, result] of Object.entries(scannerResults)) {
      comparison[scannerType] = {
        name: result.name,
        vulnerabilityCount: result.vulnerabilities.length,
        criticalCount: result.vulnerabilities.filter(v => v.severity === 'Critical').length,
        highCount: result.vulnerabilities.filter(v => v.severity === 'High').length,
        mediumCount: result.vulnerabilities.filter(v => v.severity === 'Medium').length,
        lowCount: result.vulnerabilities.filter(v => v.severity === 'Low').length,
        coverage: this.calculateCoverage(result.vulnerabilities),
        scanDuration: result.metadata?.scanDuration || 'Unknown',
        lastScan: result.timestamp
      };
    }
    
    return comparison;
  }

  /**
   * Calculate asset coverage percentage
   */
  calculateCoverage(vulnerabilities) {
    const uniqueAssets = new Set(vulnerabilities.map(v => v.asset));
    // This is a simplified calculation - in real implementation you'd compare against total assets
    return Math.round((uniqueAssets.size / Math.max(uniqueAssets.size, 1)) * 100);
  }

  /**
   * Calculate unified statistics
   */
  calculateUnifiedStatistics(vulnerabilities, scannerResults) {
    const totalScanners = Object.keys(scannerResults).length;
    const totalVulnerabilities = vulnerabilities.length;
    
    return {
      totalScanners,
      totalVulnerabilities,
      severityBreakdown: {
        critical: vulnerabilities.filter(v => v.severity === 'Critical').length,
        high: vulnerabilities.filter(v => v.severity === 'High').length,
        medium: vulnerabilities.filter(v => v.severity === 'Medium').length,
        low: vulnerabilities.filter(v => v.severity === 'Low').length
      },
      scannerCoverage: this.calculateScannerCoverage(vulnerabilities, scannerResults),
      averageConfidence: vulnerabilities.reduce((sum, v) => sum + (v.confidenceScore || 50), 0) / totalVulnerabilities
    };
  }

  /**
   * Calculate scanner coverage overlap
   */
  calculateScannerCoverage(vulnerabilities, scannerResults) {
    const coverage = {};
    
    for (const [scannerType, result] of Object.entries(scannerResults)) {
      const scannerVulns = result.vulnerabilities;
      const overlap = vulnerabilities.filter(v => 
        v.scannerSources && v.scannerSources.includes(scannerType)
      ).length;
      
      coverage[scannerType] = {
        total: scannerVulns.length,
        unique: scannerVulns.length - overlap,
        overlap: overlap,
        coveragePercentage: Math.round((overlap / Math.max(scannerVulns.length, 1)) * 100)
      };
    }
    
    return coverage;
  }

  /**
   * Calculate text similarity for conflict detection
   */
  calculateTextSimilarity(text1, text2) {
    if (!text1 || !text2) return 0;
    
    const words1 = text1.toLowerCase().split(/\s+/);
    const words2 = text2.toLowerCase().split(/\s+/);
    
    const intersection = words1.filter(word => words2.includes(word));
    const union = [...new Set([...words1, ...words2])];
    
    return intersection.length / union.length;
  }

  // Scanner-specific parsers (implementations would go here)
  async parseNessusOutput(filePath) {
    // Implementation for Nessus parsing
    return [];
  }

  async parseQualysOutput(filePath) {
    // Implementation for Qualys parsing
    return [];
  }

  async parseRapid7Output(filePath) {
    // Implementation for Rapid7 parsing
    return [];
  }

  async parseOpenVASOutput(filePath) {
    // Implementation for OpenVAS parsing
    return [];
  }

  async parseNmapOutput(filePath) {
    // Implementation for Nmap parsing
    return [];
  }

  async parseBurpOutput(filePath) {
    // Implementation for Burp parsing
    return [];
  }

  async parseCustomOutput(filePath) {
    // Implementation for custom scanner parsing
    return [];
  }

  /**
   * Extract scanner metadata
   */
  extractScannerMetadata(filePath, scannerType) {
    // Extract scan duration, timestamp, etc.
    return {
      scanDuration: 'Unknown',
      scanType: 'Full Scan',
      scannerVersion: 'Unknown'
    };
  }
}

module.exports = new ScannerIntegration();
