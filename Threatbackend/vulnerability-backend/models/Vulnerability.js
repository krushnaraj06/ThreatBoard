const mongoose = require('mongoose');

const vulnerabilitySchema = new mongoose.Schema({
  // Basic identification
  cveId: {
    type: String,
    required: true,
    index: true,
    uppercase: true
  },
  title: {
    type: String,
    required: true,
    index: true
  },
  description: {
    type: String,
    required: true
  },
  
  // Scanner information
  scannerSource: {
    type: String,
    enum: ['nessus', 'openvas', 'nmap', 'burp', 'nikto', 'custom', 'manual'],
    default: 'custom'
  },
  scannerData: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  },
  
  // Asset information
  asset: {
    type: String,
    required: true,
    index: true
  },
  assetCriticality: {
    type: String,
    enum: ['Critical', 'High', 'Medium', 'Low'],
    default: 'Medium',
    index: true
  },
  internetExposed: {
    type: Boolean,
    default: false,
    index: true
  },
  
  // CVSS and severity
  cvssScore: {
    type: Number,
    min: 0,
    max: 10,
    default: 0,
    index: true
  },
  severity: {
    type: String,
    enum: ['Critical', 'High', 'Medium', 'Low', 'Info', 'Unknown'],
    default: 'Unknown',
    index: true
  },
  finalSeverity: {
    type: String,
    enum: ['Critical', 'High', 'Medium', 'Low', 'Info'],
    required: true,
    index: true
  },
  
  // CVSS vector details
  cvssVector: String,
  attackVector: String,
  attackComplexity: String,
  privilegesRequired: String,
  userInteraction: String,
  scope: String,
  confidentialityImpact: String,
  integrityImpact: String,
  availabilityImpact: String,
  
  // Exploit and threat information
  exploitAvailable: {
    type: Boolean,
    default: false,
    index: true
  },
  cisaKevExploited: {
    type: Boolean,
    default: false,
    index: true
  },
  
  // Priority scoring
  priorityScore: {
    type: Number,
    min: 0,
    max: 100,
    required: true,
    index: true
  },
  
  // Dates
  publishedDate: {
    type: Date,
    default: Date.now,
    index: true
  },
  lastModifiedDate: Date,
  discoveredDate: {
    type: Date,
    default: Date.now
  },
  
  // Remediation
  remediation: {
    type: [String],
    default: []
  },
  remediationStatus: {
    type: String,
    enum: ['Open', 'In Progress', 'Patched', 'Mitigated', 'False Positive'],
    default: 'Open',
    index: true
  },
  remediationNotes: String,
  remediationDate: Date,
  
  // Business context
  businessImpact: {
    type: String,
    enum: ['Critical', 'High', 'Medium', 'Low', 'None'],
    default: 'Medium'
  },
  complianceRequirements: [String],
  affectedSystems: [String],
  
  // Tags and categorization
  tags: [String],
  category: {
    type: String,
    enum: ['Application', 'Network', 'Operating System', 'Database', 'Web', 'Mobile', 'IoT', 'Other'],
    default: 'Other'
  },
  
  // Risk assessment
  riskLevel: {
    type: String,
    enum: ['Extreme', 'High', 'Medium', 'Low', 'Minimal'],
    default: 'Medium',
    index: true
  },
  
  // Audit trail
  createdBy: String,
  updatedBy: String,
  createdAt: {
    type: Date,
    default: Date.now,
    index: true
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  collection: 'vulnerabilities'
});

// Indexes for better query performance
vulnerabilitySchema.index({ cveId: 1, asset: 1 });
vulnerabilitySchema.index({ priorityScore: -1, discoveredDate: -1 });
vulnerabilitySchema.index({ finalSeverity: 1, priorityScore: -1 });
vulnerabilitySchema.index({ scannerSource: 1, discoveredDate: -1 });
vulnerabilitySchema.index({ assetCriticality: 1, priorityScore: -1 });
vulnerabilitySchema.index({ internetExposed: 1, priorityScore: -1 });
vulnerabilitySchema.index({ exploitAvailable: 1, priorityScore: -1 });
vulnerabilitySchema.index({ cisaKevExploited: 1, priorityScore: -1 });

// Text search index
vulnerabilitySchema.index({
  cveId: 'text',
  title: 'text',
  description: 'text',
  asset: 'text'
});

// Pre-save middleware to update finalSeverity based on priorityScore
vulnerabilitySchema.pre('save', function(next) {
  if (this.isModified('priorityScore')) {
    if (this.priorityScore >= 90) this.finalSeverity = 'Critical';
    else if (this.priorityScore >= 70) this.finalSeverity = 'High';
    else if (this.priorityScore >= 50) this.finalSeverity = 'Medium';
    else if (this.priorityScore >= 30) this.finalSeverity = 'Low';
    else this.finalSeverity = 'Info';
  }
  
  if (this.isModified('cvssScore') && !this.severity) {
    if (this.cvssScore >= 9.0) this.severity = 'Critical';
    else if (this.cvssScore >= 7.0) this.severity = 'High';
    else if (this.cvssScore >= 4.0) this.severity = 'Medium';
    else if (this.cvssScore >= 0.1) this.severity = 'Low';
    else this.severity = 'Unknown';
  }
  
  this.updatedAt = new Date();
  next();
});

// Instance methods
vulnerabilitySchema.methods.updateRemediationStatus = function(status, notes = '') {
  this.remediationStatus = status;
  this.remediationNotes = notes;
  if (status === 'Patched' || status === 'Mitigated') {
    this.remediationDate = new Date();
  }
  return this.save();
};

vulnerabilitySchema.methods.addTag = function(tag) {
  if (!this.tags.includes(tag)) {
    this.tags.push(tag);
  }
  return this.save();
};

vulnerabilitySchema.methods.removeTag = function(tag) {
  this.tags = this.tags.filter(t => t !== tag);
  return this.save();
};

// Static methods for common queries
vulnerabilitySchema.statics.findByPriorityRange = function(minScore, maxScore) {
  return this.find({
    priorityScore: { $gte: minScore, $lte: maxScore }
  }).sort({ priorityScore: -1, discoveredDate: -1 });
};

vulnerabilitySchema.statics.findBySeverity = function(severity) {
  return this.find({ finalSeverity: severity }).sort({ priorityScore: -1 });
};

vulnerabilitySchema.statics.findByAsset = function(asset) {
  return this.find({ asset: new RegExp(asset, 'i') }).sort({ priorityScore: -1 });
};

vulnerabilitySchema.statics.findByCVE = function(cveId) {
  return this.findOne({ cveId: cveId.toUpperCase() });
};

vulnerabilitySchema.statics.findExploitable = function() {
  return this.find({ exploitAvailable: true }).sort({ priorityScore: -1 });
};

vulnerabilitySchema.statics.findCISAKEV = function() {
  return this.find({ cisaKevExploited: true }).sort({ priorityScore: -1 });
};

vulnerabilitySchema.statics.findInternetExposed = function() {
  return this.find({ internetExposed: true }).sort({ priorityScore: -1 });
};

vulnerabilitySchema.statics.getStatistics = function() {
  return this.aggregate([
    {
      $group: {
        _id: null,
        total: { $sum: 1 },
        avgPriorityScore: { $avg: '$priorityScore' },
        criticalCount: { $sum: { $cond: [{ $eq: ['$finalSeverity', 'Critical'] }, 1, 0] } },
        highCount: { $sum: { $cond: [{ $eq: ['$finalSeverity', 'High'] }, 1, 0] } },
        mediumCount: { $sum: { $cond: [{ $eq: ['$finalSeverity', 'Medium'] }, 1, 0] } },
        lowCount: { $sum: { $cond: [{ $eq: ['$finalSeverity', 'Low'] }, 1, 0] } },
        exploitCount: { $sum: { $cond: ['$exploitAvailable', 1, 0] } },
        cisaKevCount: { $sum: { $cond: ['$cisaKevExploited', 1, 0] } },
        internetExposedCount: { $sum: { $cond: ['$internetExposed', 1, 0] } }
      }
    }
  ]);
};

vulnerabilitySchema.statics.getSeverityDistribution = function() {
  return this.aggregate([
    {
      $group: {
        _id: '$finalSeverity',
        count: { $sum: 1 },
        avgPriorityScore: { $avg: '$priorityScore' }
      }
    },
    {
      $sort: { count: -1 }
    }
  ]);
};

vulnerabilitySchema.statics.getAssetCriticalityDistribution = function() {
  return this.aggregate([
    {
      $group: {
        _id: '$assetCriticality',
        count: { $sum: 1 },
        avgPriorityScore: { $avg: '$priorityScore' }
      }
    },
    {
      $sort: { count: -1 }
    }
  ]);
};

vulnerabilitySchema.statics.searchVulnerabilities = function(query, filters = {}) {
  const searchQuery = {};
  
  // Text search
  if (query) {
    searchQuery.$text = { $search: query };
  }
  
  // Apply filters
  if (filters.severity) {
    searchQuery.finalSeverity = filters.severity;
  }
  
  if (filters.assetCriticality) {
    searchQuery.assetCriticality = filters.assetCriticality;
  }
  
  if (filters.exploitAvailable !== undefined) {
    searchQuery.exploitAvailable = filters.exploitAvailable;
  }
  
  if (filters.cisaKevExploited !== undefined) {
    searchQuery.cisaKevExploited = filters.cisaKevExploited;
  }
  
  if (filters.internetExposed !== undefined) {
    searchQuery.internetExposed = filters.internetExposed;
  }
  
  if (filters.scannerSource) {
    searchQuery.scannerSource = filters.scannerSource;
  }
  
  if (filters.minPriorityScore) {
    searchQuery.priorityScore = { $gte: filters.minPriorityScore };
  }
  
  if (filters.maxPriorityScore) {
    if (searchQuery.priorityScore) {
      searchQuery.priorityScore.$lte = filters.maxPriorityScore;
    } else {
      searchQuery.priorityScore = { $lte: filters.maxPriorityScore };
    }
  }
  
  return this.find(searchQuery)
    .sort({ priorityScore: -1, discoveredDate: -1 });
};

module.exports = mongoose.model('Vulnerability', vulnerabilitySchema);
