const Vulnerability = require('../models/Vulnerability');
const FileParser = require('../services/fileParser');
const VulnerabilityEnrichment = require('../services/vulnerabilityEnrichment');
const ScannerIntegration = require('../services/scannerIntegration');
const AdvancedSearch = require('../services/advancedSearch');
const FalsePositiveReduction = require('../services/falsePositiveReduction');
const ScannerHealthMonitoring = require('../services/scannerHealthMonitoring');

class VulnerabilityController {
  constructor() {
    this.fileParser = FileParser;
    this.vulnerabilityEnrichment = VulnerabilityEnrichment;
    this.scannerIntegration = ScannerIntegration;
    this.advancedSearch = AdvancedSearch;
    this.falsePositiveReduction = FalsePositiveReduction;
    this.scannerHealthMonitoring = ScannerHealthMonitoring;
  }

  /**
   * Upload and parse scanner output files
   */
  async uploadScannerOutput(req, res) {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'No file uploaded' });
      }

      console.log(`ðŸ“ Processing uploaded file: ${req.file.originalname}`);
      
      // Parse the uploaded file
      const vulnerabilities = await this.fileParser.parseFile(req.file.path);
      
      if (!vulnerabilities || vulnerabilities.length === 0) {
        return res.status(400).json({ 
          error: 'No vulnerabilities found in the uploaded file',
          suggestions: [
            'Check if the file contains vulnerability data',
            'Verify the file format is supported (JSON, XML, CSV)',
            'Ensure the file is not corrupted or empty'
          ]
        });
      }

      // Analyze parsing quality
      const parsingQuality = this.analyzeParsingQuality(vulnerabilities);
      
      // Enrich vulnerabilities with external data
      const enrichedVulnerabilities = await this.enrichVulnerabilities(vulnerabilities);
      
      // Save to database
      const savedVulnerabilities = await this.saveVulnerabilities(enrichedVulnerabilities);
      
      // Analyze for false positives
      const falsePositiveAnalysis = await this.falsePositiveReduction.analyzeFalsePositives(savedVulnerabilities);
      
      console.log(`âœ… File processed successfully: ${savedVulnerabilities.length} vulnerabilities saved`);

      res.status(200).json({
        message: 'File uploaded and processed successfully',
        totalVulnerabilities: savedVulnerabilities.length,
        parsingQuality: parsingQuality,
        falsePositiveAnalysis: falsePositiveAnalysis.summary,
        recommendations: falsePositiveAnalysis.recommendations
      });

    } catch (error) {
      console.error('âŒ File upload failed:', error.message);
      res.status(500).json({ 
        error: 'Failed to process uploaded file',
        details: error.message,
        suggestions: [
          'Check file format and content',
          'Verify file is not corrupted',
          'Ensure file contains vulnerability data'
        ]
      });
    }
  }

  /**
   * Get all vulnerabilities with filtering and pagination
   */
  async getVulnerabilities(req, res) {
    try {
      const { page = 1, limit = 20, severity, scanner, asset, sortBy, sortOrder } = req.query;
      
      const filter = {};
      if (severity) filter.finalSeverity = severity;
      if (scanner) filter.scannerSource = { $regex: scanner, $options: 'i' };
      if (asset) filter.asset = { $regex: asset, $options: 'i' };

      const sort = {};
      if (sortBy) {
        sort[sortBy] = sortOrder === 'desc' ? -1 : 1;
      } else {
        sort.priorityScore = -1;
        sort.finalSeverity = -1;
      }

      const skip = (parseInt(page) - 1) * parseInt(limit);
      
      const vulnerabilities = await Vulnerability.find(filter)
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .lean();

      const total = await Vulnerability.countDocuments(filter);

      res.status(200).json({
        vulnerabilities,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / parseInt(limit))
        }
      });

    } catch (error) {
      console.error('âŒ Failed to get vulnerabilities:', error.message);
      res.status(500).json({ error: 'Failed to retrieve vulnerabilities' });
    }
  }

  /**
   * Advanced search with natural language queries
   */
  async advancedSearchHandler(req, res) {
    try {
      const { query, page = 1, limit = 20, sortBy, sortOrder } = req.query;
      
      if (!query) {
        return res.status(400).json({ error: 'Search query is required' });
      }

      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        sortBy,
        sortOrder
      };

      const searchResults = await this.advancedSearch.advancedSearch(query, options);
      
      res.status(200).json(searchResults);

    } catch (error) {
      console.error('âŒ Advanced search failed:', error.message);
      res.status(500).json({ error: 'Search failed', details: error.message });
    }
  }

  /**
   * Get saved search templates
   */
  async getSavedSearches(req, res) {
    try {
      const { userId } = req.params;
      const savedSearches = await this.advancedSearch.getSavedSearches(userId);
      
      res.status(200).json({ savedSearches });

    } catch (error) {
      console.error('âŒ Failed to get saved searches:', error.message);
      res.status(500).json({ error: 'Failed to retrieve saved searches' });
    }
  }

  /**
   * Execute a saved search
   */
  async executeSavedSearch(req, res) {
    try {
      const { searchId } = req.params;
      const { page = 1, limit = 20 } = req.query;
      
      const options = {
        page: parseInt(page),
        limit: parseInt(limit)
      };

      const searchResults = await this.advancedSearch.executeSavedSearch(searchId, options);
      
      res.status(200).json(searchResults);

    } catch (error) {
      console.error('âŒ Failed to execute saved search:', error.message);
      res.status(500).json({ error: 'Failed to execute saved search', details: error.message });
    }
  }

  /**
   * Get search analytics
   */
  async getSearchAnalytics(req, res) {
    try {
      const analytics = await this.advancedSearch.getSearchAnalytics();
      
      res.status(200).json({ analytics });

    } catch (error) {
      console.error('âŒ Failed to get search analytics:', error.message);
      res.status(500).json({ error: 'Failed to retrieve search analytics' });
    }
  }

  /**
   * Integrate multiple scanner outputs
   */
  async integrateScannerOutputs(req, res) {
    try {
      const { scannerFiles } = req.body;
      
      if (!scannerFiles || !Array.isArray(scannerFiles) || scannerFiles.length === 0) {
        return res.status(400).json({ error: 'Scanner files array is required' });
      }

      const integrationResults = await this.scannerIntegration.integrateScannerOutputs(scannerFiles);
      
      res.status(200).json({
        message: 'Scanner outputs integrated successfully',
        ...integrationResults
      });

    } catch (error) {
      console.error('âŒ Scanner integration failed:', error.message);
      res.status(500).json({ error: 'Scanner integration failed', details: error.message });
    }
  }

  /**
   * Get scanner comparison metrics
   */
  async getScannerComparison(req, res) {
    try {
      const { scannerType } = req.params;
      
      if (scannerType) {
        // Get comparison for specific scanner
        const scannerHealth = await this.scannerHealthMonitoring.checkScannerHealth(scannerType);
        res.status(200).json({ scannerHealth });
      } else {
        // Get comparison for all scanners
        const healthReport = await this.scannerHealthMonitoring.monitorScannerHealth();
        res.status(200).json({ healthReport });
      }

    } catch (error) {
      console.error('âŒ Failed to get scanner comparison:', error.message);
      res.status(500).json({ error: 'Failed to retrieve scanner comparison', details: error.message });
    }
  }

  /**
   * Get scanner comparison for specific scanner type
   */
  async getScannerComparisonByType(req, res) {
    try {
      const { scannerType } = req.params;
      
      if (!scannerType) {
        return res.status(400).json({ error: 'Scanner type is required' });
      }

      const scannerHealth = await this.scannerHealthMonitoring.checkScannerHealth(scannerType);
      res.status(200).json({ scannerHealth });

    } catch (error) {
      console.error('âŒ Failed to get scanner comparison for type:', error.message);
      res.status(500).json({ error: 'Failed to retrieve scanner comparison', details: error.message });
    }
  }

  /**
   * Monitor scanner health
   */
  async monitorScannerHealth(req, res) {
    try {
      const healthReport = await this.scannerHealthMonitoring.monitorScannerHealth();
      
      res.status(200).json({ healthReport });

    } catch (error) {
      console.error('âŒ Scanner health monitoring failed:', error.message);
      res.status(500).json({ error: 'Health monitoring failed', details: error.message });
    }
  }

  /**
   * Get scanner health history
   */
  async getScannerHealthHistory(req, res) {
    try {
      const { scannerType } = req.params;
      const { days = 30 } = req.query;
      
      const history = await this.scannerHealthMonitoring.getScannerHealthHistory(scannerType, parseInt(days));
      
      res.status(200).json({ history });

    } catch (error) {
      console.error('âŒ Failed to get scanner health history:', error.message);
      res.status(500).json({ error: 'Failed to retrieve health history', details: error.message });
    }
  }

  /**
   * Analyze false positives for vulnerabilities
   */
  async analyzeFalsePositives(req, res) {
    try {
      const { vulnerabilityIds } = req.body;
      
      if (!vulnerabilityIds || !Array.isArray(vulnerabilityIds)) {
        return res.status(400).json({ error: 'Vulnerability IDs array is required' });
      }

      const vulnerabilities = await Vulnerability.find({ _id: { $in: vulnerabilityIds } });
      
      if (vulnerabilities.length === 0) {
        return res.status(404).json({ error: 'No vulnerabilities found' });
      }

      const analysis = await this.falsePositiveReduction.analyzeFalsePositives(vulnerabilities);
      
      res.status(200).json({
        message: 'False positive analysis completed',
        ...analysis
      });

    } catch (error) {
      console.error('âŒ False positive analysis failed:', error.message);
      res.status(500).json({ error: 'False positive analysis failed', details: error.message });
    }
  }

  /**
   * Update false positive analysis for a vulnerability
   */
  async updateFalsePositiveAnalysis(req, res) {
    try {
      const { vulnerabilityId } = req.params;
      const { analysis } = req.body;
      
      if (!analysis) {
        return res.status(400).json({ error: 'Analysis data is required' });
      }

      const result = await this.falsePositiveReduction.updateFalsePositiveAnalysis(vulnerabilityId, analysis);
      
      res.status(200).json({
        message: 'False positive analysis updated successfully',
        ...result
      });

    } catch (error) {
      console.error('âŒ Failed to update false positive analysis:', error.message);
      res.status(500).json({ error: 'Failed to update analysis', details: error.message });
    }
  }

  /**
   * Get false positive statistics
   */
  async getFalsePositiveStatistics(req, res) {
    try {
      const stats = await this.falsePositiveReduction.getFalsePositiveStatistics();
      
      res.status(200).json({ stats });

    } catch (error) {
      console.error('âŒ Failed to get false positive statistics:', error.message);
      res.status(500).json({ error: 'Failed to retrieve false positive statistics' });
    }
  }

  /**
   * Get vulnerability statistics
   */
  async getStatistics(req, res) {
    try {
      const stats = await Vulnerability.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            bySeverity: {
              $push: {
                severity: '$finalSeverity',
                count: 1
              }
            },
            byScanner: {
              $push: {
                scanner: '$scannerSource',
                count: 1
              }
            },
            averagePriorityScore: { $avg: '$priorityScore' },
            averageConfidenceScore: { $avg: '$confidenceScore' }
          }
        }
      ]);

      if (stats.length === 0) {
        return res.status(200).json({
          total: 0,
          bySeverity: {},
          byScanner: {},
          averagePriorityScore: 0,
          averageConfidenceScore: 0
        });
      }

      const result = stats[0];
      
      // Process severity breakdown
      const severityBreakdown = {};
      result.bySeverity.forEach(item => {
        if (!severityBreakdown[item.severity]) {
          severityBreakdown[item.severity] = 0;
        }
        severityBreakdown[item.severity] += item.count;
      });

      // Process scanner breakdown
      const scannerBreakdown = {};
      result.byScanner.forEach(item => {
        if (!scannerBreakdown[item.scanner]) {
          scannerBreakdown[item.scanner] = 0;
        }
        scannerBreakdown[item.scanner] += item.count;
      });

      res.status(200).json({
        total: result.total,
        bySeverity: severityBreakdown,
        byScanner: scannerBreakdown,
        averagePriorityScore: Math.round(result.averagePriorityScore || 0),
        averageConfidenceScore: Math.round(result.averageConfidenceScore || 0)
      });

    } catch (error) {
      console.error('âŒ Failed to get statistics:', error.message);
      res.status(500).json({ error: 'Failed to retrieve statistics' });
    }
  }

  /**
   * Get latest CVEs from NVD
   */
  async getLatestCVEs(req, res) {
    try {
      const { limit = 10, days = 7 } = req.query;
      
      const latestCVEs = await this.vulnerabilityEnrichment.getLatestCVEs(parseInt(limit), parseInt(days));
      
      res.status(200).json({
        message: 'Latest CVEs retrieved successfully',
        cves: latestCVEs,
        count: latestCVEs.length
      });

    } catch (error) {
      console.error('âŒ Failed to get latest CVEs:', error.message);
      res.status(500).json({ error: 'Failed to retrieve latest CVEs', details: error.message });
    }
  }

  /**
   * Search CVEs by keyword
   */
  async searchCVEsByKeyword(req, res) {
    try {
      const { keyword, limit = 20 } = req.query;
      
      if (!keyword) {
        return res.status(400).json({ error: 'Keyword is required' });
      }

      const searchResults = await this.vulnerabilityEnrichment.searchCVEsByKeyword(keyword, parseInt(limit));
      
      res.status(200).json({
        message: 'CVE search completed successfully',
        keyword,
        results: searchResults,
        count: searchResults.length
      });

    } catch (error) {
      console.error('âŒ CVE search failed:', error.message);
      res.status(500).json({ error: 'CVE search failed', details: error.message });
    }
  }

  /**
   * Check NVD API status
   */
  async getNVDStatus(req, res) {
    try {
      const status = await this.vulnerabilityEnrichment.getNVDStatus();
      
      res.status(200).json({
        message: 'NVD API status checked successfully',
        status
      });

    } catch (error) {
      console.error('âŒ Failed to check NVD status:', error.message);
      res.status(500).json({ error: 'Failed to check NVD status', details: error.message });
    }
  }

  /**
   * Get vulnerability by ID
   */
  async getVulnerabilityById(req, res) {
    try {
      const { id } = req.params;
      
      const vulnerability = await Vulnerability.findById(id);
      
      if (!vulnerability) {
        return res.status(404).json({ error: 'Vulnerability not found' });
      }

      res.status(200).json({ vulnerability });

    } catch (error) {
      console.error('âŒ Failed to get vulnerability:', error.message);
      res.status(500).json({ error: 'Failed to retrieve vulnerability' });
    }
  }

  /**
   * Update vulnerability
   */
  async updateVulnerability(req, res) {
    try {
      const { id } = req.params;
      const updateData = req.body;
      
      const vulnerability = await Vulnerability.findByIdAndUpdate(
        id, 
        { ...updateData, updatedAt: new Date() },
        { new: true, runValidators: true }
      );
      
      if (!vulnerability) {
        return res.status(404).json({ error: 'Vulnerability not found' });
      }

      res.status(200).json({
        message: 'Vulnerability updated successfully',
        vulnerability
      });

    } catch (error) {
      console.error('âŒ Failed to update vulnerability:', error.message);
      res.status(500).json({ error: 'Failed to update vulnerability', details: error.message });
    }
  }

  /**
   * Delete vulnerability
   */
  async deleteVulnerability(req, res) {
    try {
      const { id } = req.params;
      
      const vulnerability = await Vulnerability.findByIdAndDelete(id);
      
      if (!vulnerability) {
        return res.status(404).json({ error: 'Vulnerability not found' });
      }

      res.status(200).json({
        message: 'Vulnerability deleted successfully',
        deletedVulnerability: vulnerability
      });

    } catch (error) {
      console.error('âŒ Failed to delete vulnerability:', error.message);
      res.status(500).json({ error: 'Failed to delete vulnerability', details: error.message });
    }
  }

  /**
   * Bulk update vulnerabilities
   */
  async bulkUpdateVulnerabilities(req, res) {
    try {
      const { vulnerabilityIds, updateData } = req.body;
      
      if (!vulnerabilityIds || !Array.isArray(vulnerabilityIds) || !updateData) {
        return res.status(400).json({ error: 'Vulnerability IDs array and update data are required' });
      }

      const result = await Vulnerability.updateMany(
        { _id: { $in: vulnerabilityIds } },
        { ...updateData, updatedAt: new Date() }
      );

      res.status(200).json({
        message: 'Bulk update completed successfully',
        modifiedCount: result.modifiedCount,
        matchedCount: result.matchedCount
      });

    } catch (error) {
      console.error('âŒ Bulk update failed:', error.message);
      res.status(500).json({ error: 'Bulk update failed', details: error.message });
    }
  }

  /**
   * Export vulnerabilities
   */
  async exportVulnerabilities(req, res) {
    try {
      const { format = 'json', filters } = req.query;
      
      let query = {};
      if (filters) {
        try {
          query = JSON.parse(filters);
        } catch (e) {
          return res.status(400).json({ error: 'Invalid filters format' });
        }
      }

      const vulnerabilities = await Vulnerability.find(query).lean();
      
      if (format === 'csv') {
        // Convert to CSV format
        const csv = this.convertToCSV(vulnerabilities);
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename=vulnerabilities.csv');
        res.status(200).send(csv);
      } else {
        // Default JSON format
        res.status(200).json({
          message: 'Vulnerabilities exported successfully',
          format: 'json',
          count: vulnerabilities.length,
          vulnerabilities
        });
      }

    } catch (error) {
      console.error('âŒ Export failed:', error.message);
      res.status(500).json({ error: 'Export failed', details: error.message });
    }
  }

  // Helper methods

  /**
   * Analyze parsing quality of extracted vulnerabilities
   */
  analyzeParsingQuality(vulnerabilities) {
    const totalVulns = vulnerabilities.length;
    let totalScore = 0;
    const metrics = {
      hasCVE: 0,
      hasDescription: 0,
      hasSeverity: 0,
      hasAsset: 0,
      hasCVSS: 0
    };

    vulnerabilities.forEach(vuln => {
      if (vuln.cveId && vuln.cveId !== 'N/A') metrics.hasCVE++;
      if (vuln.description && vuln.description.length > 10) metrics.hasDescription++;
      if (vuln.severity && vuln.severity !== 'Unknown') metrics.hasSeverity++;
      if (vuln.asset && vuln.asset !== 'Unknown') metrics.hasAsset++;
      if (vuln.cvssScore && vuln.cvssScore > 0) metrics.hasCVSS++;
    });

    // Calculate quality score (0-100)
    const scores = [
      (metrics.hasCVE / totalVulns) * 20,
      (metrics.hasDescription / totalVulns) * 25,
      (metrics.hasSeverity / totalVulns) * 20,
      (metrics.hasAsset / totalVulns) * 20,
      (metrics.hasCVSS / totalVulns) * 15
    ];

    totalScore = Math.round(scores.reduce((sum, score) => sum + score, 0));

    return {
      score: totalScore,
      grade: this.getQualityGrade(totalScore),
      metrics: metrics,
      recommendations: this.getQualityRecommendations(totalScore, metrics)
    };
  }

  /**
   * Get quality grade based on score
   */
  getQualityGrade(score) {
    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
  }

  /**
   * Get quality improvement recommendations
   */
  getQualityRecommendations(score, metrics) {
    const recommendations = [];
    
    if (score < 80) {
      if (metrics.hasCVE / metrics.total < 0.8) {
        recommendations.push('Improve CVE ID extraction - many vulnerabilities lack CVE identifiers');
      }
      if (metrics.hasDescription / metrics.total < 0.8) {
        recommendations.push('Enhance description extraction - descriptions are incomplete or missing');
      }
      if (metrics.hasSeverity / metrics.total < 0.8) {
        recommendations.push('Improve severity classification - many vulnerabilities have unknown severity');
      }
      if (metrics.hasAsset / metrics.total < 0.8) {
        recommendations.push('Better asset identification - asset information is incomplete');
      }
      if (metrics.hasCVSS / metrics.total < 0.8) {
        recommendations.push('Enhance CVSS score extraction - CVSS scores are missing');
      }
    }

    if (recommendations.length === 0) {
      recommendations.push('Excellent data quality! Consider adding more detailed asset information');
    }

    return recommendations;
  }

  /**
   * Enrich vulnerabilities with external data
   */
  async enrichVulnerabilities(vulnerabilities) {
    console.log(`ðŸ”— Enriching ${vulnerabilities.length} vulnerabilities...`);
    
    const enrichedVulnerabilities = [];
    
    for (let i = 0; i < vulnerabilities.length; i++) {
      const vuln = vulnerabilities[i];
      
      try {
        // Enrich with NVD data if CVE ID is available
        if (vuln.cveId && vuln.cveId !== 'N/A') {
          const nvdData = await this.vulnerabilityEnrichment.getNVDData(vuln.cveId);
          if (nvdData) {
            vuln.cvssScore = nvdData.cvssScore || vuln.cvssScore;
            vuln.description = nvdData.description || vuln.description;
            vuln.severity = nvdData.severity || vuln.severity;
            vuln.publishedDate = nvdData.publishedDate || vuln.publishedDate;
          }
        }

        // Calculate priority score
        vuln.priorityScore = this.calculatePriorityScore(vuln);
        
        // Set final severity
        vuln.finalSeverity = vuln.severity || 'Unknown';
        
        // Set discovered date
        vuln.discoveredDate = new Date();
        
        enrichedVulnerabilities.push(vuln);
        
        // Rate limiting for external API calls
        if (i < vulnerabilities.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        
      } catch (error) {
        console.warn(`âš ï¸ Failed to enrich vulnerability ${vuln.cveId || vuln.title}:`, error.message);
        enrichedVulnerabilities.push(vuln);
      }
    }

    console.log(`âœ… Enrichment completed: ${enrichedVulnerabilities.length} vulnerabilities processed`);
    return enrichedVulnerabilities;
  }

  /**
   * Calculate priority score for vulnerability
   */
  calculatePriorityScore(vulnerability) {
    let score = 0;
    
    // Base CVSS score (50% weight)
    if (vulnerability.cvssScore) {
      score += (vulnerability.cvssScore / 10) * 50;
    }
    
    // Asset criticality (30% weight)
    if (vulnerability.assetCriticality === 'Critical') {
      score += 30;
    } else if (vulnerability.assetCriticality === 'High') {
      score += 20;
    } else if (vulnerability.assetCriticality === 'Medium') {
      score += 10;
    }
    
    // Internet exposure (20% weight)
    if (vulnerability.internetExposed) {
      score += 20;
    }
    
    return Math.min(Math.round(score), 100);
  }

  /**
   * Save vulnerabilities to database
   */
  async saveVulnerabilities(vulnerabilities) {
    try {
      const savedVulnerabilities = [];
      
      for (const vuln of vulnerabilities) {
        try {
          const savedVuln = await Vulnerability.create(vuln);
          savedVulnerabilities.push(savedVuln);
        } catch (error) {
          console.warn(`âš ï¸ Failed to save vulnerability ${vuln.cveId || vuln.title}:`, error.message);
        }
      }
      
      return savedVulnerabilities;
      
    } catch (error) {
      console.error('âŒ Failed to save vulnerabilities:', error.message);
      throw error;
    }
  }

  /**
   * Convert vulnerabilities to CSV format
   */
  convertToCSV(vulnerabilities) {
    if (vulnerabilities.length === 0) return '';
    
    const headers = Object.keys(vulnerabilities[0]);
    const csvRows = [headers.join(',')];
    
    vulnerabilities.forEach(vuln => {
      const values = headers.map(header => {
        const value = vuln[header];
        if (typeof value === 'string' && value.includes(',')) {
          return `"${value}"`;
        }
        return value || '';
      });
      csvRows.push(values.join(','));
    });
    
    return csvRows.join('\n');
  }
}

module.exports = new VulnerabilityController();
